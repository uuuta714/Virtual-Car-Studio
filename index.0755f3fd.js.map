{"mappings":"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","sources":["node_modules/webm-writer/WebMWriter.js"],"sourcesContent":["/**\n * WebM video encoder for Google Chrome. This implementation is suitable for creating very large video files, because\n * it can stream Blobs directly to a FileWriter without buffering the entire video in memory.\n *\n * When FileWriter is not available or not desired, it can buffer the video in memory as a series of Blobs which are\n * eventually returned as one composite Blob.\n *\n * By Nicholas Sherlock.\n *\n * Based on the ideas from Whammy: https://github.com/antimatter15/whammy\n *\n * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n */\n\n\"use strict\";\n\n(function() {\n    function extend(base, top) {\n        let\n            target = {};\n        \n        [base, top].forEach(function(obj) {\n            for (let prop in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n                    target[prop] = obj[prop];\n                }\n            }\n        });\n        \n        return target;\n    }\n    \n    /**\n     * Decode a Base64 data URL into a binary string.\n     *\n     * @return {String} The binary string\n     */\n    function decodeBase64WebPDataURL(url) {\n        if (typeof url !== \"string\" || !url.match(/^data:image\\/webp;base64,/i)) {\n            throw new Error(\"Failed to decode WebP Base64 URL\");\n        }\n        \n        return window.atob(url.substring(\"data:image\\/webp;base64,\".length));\n    }\n    \n    /**\n     * Convert the given canvas to a WebP encoded image and return the image data as a string.\n     *\n     * @return {String}\n     */\n    function renderAsWebP(canvas, quality) {\n        let\n            frame = typeof canvas === 'string' && /^data:image\\/webp/.test(canvas)\n                ? canvas\n                : canvas.toDataURL('image/webp', quality);\n        \n        return decodeBase64WebPDataURL(frame);\n    }\n    \n    /**\n     * @param {String} string\n     * @returns {number}\n     */\n    function byteStringToUint32LE(string) {\n        let\n            a = string.charCodeAt(0),\n            b = string.charCodeAt(1),\n            c = string.charCodeAt(2),\n            d = string.charCodeAt(3);\n    \n        return (a | (b << 8) | (c << 16) | (d << 24)) >>> 0;\n    }\n    \n    /**\n     * Extract a VP8 keyframe from a WebP image file.\n     *\n     * @param {String} webP - Raw binary string\n     *\n     * @returns {{hasAlpha: boolean, frame: string}}\n     */\n    function extractKeyframeFromWebP(webP) {\n        let\n            cursor = webP.indexOf('VP8', 12); // Start the search after the 12-byte file header\n    \n        if (cursor === -1) {\n            throw new Error(\"Bad image format, does this browser support WebP?\");\n        }\n        \n        let\n            hasAlpha = false;\n    \n        /* Cursor now is either directly pointing at a \"VP8 \" keyframe, or a \"VP8X\" extended format file header\n         * Seek through chunks until we find the \"VP8 \" chunk we're interested in\n         */\n        while (cursor < webP.length - 8) {\n            let\n                chunkLength, fourCC;\n    \n            fourCC = webP.substring(cursor, cursor + 4);\n            cursor += 4;\n\n            chunkLength = byteStringToUint32LE(webP.substring(cursor, cursor + 4));\n            cursor += 4;\n            \n            switch (fourCC) {\n                case \"VP8 \":\n                    return {\n                        frame: webP.substring(cursor, cursor + chunkLength),\n                        hasAlpha: hasAlpha\n                    };\n                    \n                case \"ALPH\":\n                    hasAlpha = true;\n                    /* But we otherwise ignore the content of the alpha chunk, since we don't have a decoder for it\n                     * and it isn't VP8-compatible\n                     */\n                    break;\n            }\n            \n            cursor += chunkLength;\n            \n            if ((chunkLength & 0x01) !== 0) {\n                cursor++;\n                // Odd-length chunks have 1 byte of trailing padding that isn't included in their length\n            }\n        }\n        \n        throw new Error(\"Failed to find VP8 keyframe in WebP image, is this image mistakenly encoded in the Lossless WebP format?\");\n    }\n    \n    const \n        EBML_SIZE_UNKNOWN = -1,\n        EBML_SIZE_UNKNOWN_5_BYTES = -2;\n    \n    // Just a little utility so we can tag values as floats for the EBML encoder's benefit\n    function EBMLFloat32(value) {\n        this.value = value;\n    }\n    \n    function EBMLFloat64(value) {\n        this.value = value;\n    }\n    \n    /**\n     * Write the given EBML object to the provided ArrayBufferStream.\n     *\n     * @param buffer\n     * @param {Number} bufferFileOffset - The buffer's first byte is at this position inside the video file.\n     *                                    This is used to complete offset and dataOffset fields in each EBML structure,\n     *                                    indicating the file offset of the first byte of the EBML element and\n     *                                    its data payload.\n     * @param {*} ebml\n     */\n    function writeEBML(buffer, bufferFileOffset, ebml) {\n        // Is the ebml an array of sibling elements?\n        if (Array.isArray(ebml)) {\n            for (let i = 0; i < ebml.length; i++) {\n                writeEBML(buffer, bufferFileOffset, ebml[i]);\n            }\n            // Is this some sort of raw data that we want to write directly?\n        } else if (typeof ebml === \"string\") {\n            buffer.writeString(ebml);\n        } else if (ebml instanceof Uint8Array) {\n            buffer.writeBytes(ebml);\n        } else if (ebml.id){\n            // We're writing an EBML element\n            ebml.offset = buffer.pos + bufferFileOffset;\n            \n            buffer.writeUnsignedIntBE(ebml.id); // ID field\n            \n            // Now we need to write the size field, so we must know the payload size:\n            \n            if (Array.isArray(ebml.data)) {\n                // Writing an array of child elements. We won't try to measure the size of the children up-front\n                \n                let\n                    sizePos, dataBegin, dataEnd;\n                \n                if (ebml.size === EBML_SIZE_UNKNOWN) {\n                    // Write the reserved all-one-bits marker to note that the size of this element is unknown/unbounded\n                    buffer.writeByte(0xFF);\n                } else if (ebml.size === EBML_SIZE_UNKNOWN_5_BYTES) {\n                    sizePos = buffer.pos;\n                    \n                    // VINT_DATA is all-ones, so this is the reserved \"unknown length\" marker:\n                    buffer.writeBytes([0x0F, 0xFF, 0xFF, 0xFF, 0xFF]);\n                } else {\n                    sizePos = buffer.pos;\n                    \n                    /* Write a dummy size field to overwrite later. 4 bytes allows an element maximum size of 256MB,\n\t\t\t\t\t * which should be plenty (we don't want to have to buffer that much data in memory at one time\n\t\t\t\t\t * anyway!)\n\t\t\t\t\t */\n                    buffer.writeBytes([0, 0, 0, 0]);\n                }\n                \n                dataBegin = buffer.pos;\n                \n                ebml.dataOffset = dataBegin + bufferFileOffset;\n                writeEBML(buffer, bufferFileOffset, ebml.data);\n                \n                if (ebml.size !== EBML_SIZE_UNKNOWN && ebml.size !== EBML_SIZE_UNKNOWN_5_BYTES) {\n                    dataEnd = buffer.pos;\n                    \n                    ebml.size = dataEnd - dataBegin;\n                    \n                    buffer.seek(sizePos);\n                    buffer.writeEBMLVarIntWidth(ebml.size, 4); // Size field\n                    \n                    buffer.seek(dataEnd);\n                }\n            } else if (typeof ebml.data === \"string\") {\n                buffer.writeEBMLVarInt(ebml.data.length); // Size field\n                ebml.dataOffset = buffer.pos + bufferFileOffset;\n                buffer.writeString(ebml.data);\n            } else if (typeof ebml.data === \"number\") {\n                // Allow the caller to explicitly choose the size if they wish by supplying a size field\n                if (!ebml.size) {\n                    ebml.size = buffer.measureUnsignedInt(ebml.data);\n                }\n                \n                buffer.writeEBMLVarInt(ebml.size); // Size field\n                ebml.dataOffset = buffer.pos + bufferFileOffset;\n                buffer.writeUnsignedIntBE(ebml.data, ebml.size);\n            } else if (ebml.data instanceof EBMLFloat64) {\n                buffer.writeEBMLVarInt(8); // Size field\n                ebml.dataOffset = buffer.pos + bufferFileOffset;\n                buffer.writeDoubleBE(ebml.data.value);\n            } else if (ebml.data instanceof EBMLFloat32) {\n                buffer.writeEBMLVarInt(4); // Size field\n                ebml.dataOffset = buffer.pos + bufferFileOffset;\n                buffer.writeFloatBE(ebml.data.value);\n            } else if (ebml.data instanceof Uint8Array) {\n                buffer.writeEBMLVarInt(ebml.data.byteLength); // Size field\n                ebml.dataOffset = buffer.pos + bufferFileOffset;\n                buffer.writeBytes(ebml.data);\n            } else {\n                throw new Error(\"Bad EBML datatype \" + typeof ebml.data);\n            }\n        } else {\n            throw new Error(\"Bad EBML datatype \" + typeof ebml.data);\n        }\n    }\n    \n    /**\n     * @typedef {Object} Frame\n     * @property {string} frame - Raw VP8 keyframe data\n     * @property {string} alpha - Raw VP8 keyframe with alpha represented as luminance\n     * @property {Number} duration\n     * @property {Number} trackNumber - From 1 to 126 (inclusive)\n     * @property {Number} timecode\n     */\n    \n    /**\n     * @typedef {Object} Cluster\n     * @property {Number} timecode - Start time for the cluster\n     */\n    \n    /**\n     * @param ArrayBufferDataStream - Imported library\n     * @param BlobBuffer - Imported library\n     *\n     * @returns WebMWriter\n     *\n     * @constructor\n     */\n    let WebMWriter = function(ArrayBufferDataStream, BlobBuffer) {\n        return function(options) {\n            let\n                MAX_CLUSTER_DURATION_MSEC = 5000,\n                DEFAULT_TRACK_NUMBER = 1,\n            \n                writtenHeader = false,\n                videoWidth = 0, videoHeight = 0,\n    \n                /**\n                 * @type {[HTMLCanvasElement]}\n                 */\n                alphaBuffer = null,\n\n                /**\n                 * @type {[CanvasRenderingContext2D]}\n                 */\n                alphaBufferContext = null,\n\n                /**\n                 * @type {[ImageData]}\n                 */\n                alphaBufferData = null,\n    \n                /**\n                 *\n                 * @type {Frame[]}\n                 */\n                clusterFrameBuffer = [],\n                clusterStartTime = 0,\n                clusterDuration = 0,\n                \n                optionDefaults = {\n                    quality: 0.95,       // WebM image quality from 0.0 (worst) to 0.99999 (best), 1.00 (WebP lossless) is not supported\n                    \n                    transparent: false,      // True if an alpha channel should be included in the video\n                    alphaQuality: undefined, // Allows you to set the quality level of the alpha channel separately.\n                                             // If not specified this defaults to the same value as `quality`.\n                    \n                    fileWriter: null,    // Chrome FileWriter in order to stream to a file instead of buffering to memory (optional)\n                    fd: null,            // Node.JS file descriptor to write to instead of buffering (optional)\n                    \n                    // You must supply one of:\n                    frameDuration: null, // Duration of frames in milliseconds\n                    frameRate: null,     // Number of frames per second\n                },\n                \n                seekPoints = {\n                    Cues: {id: new Uint8Array([0x1C, 0x53, 0xBB, 0x6B]), positionEBML: null},\n                    SegmentInfo: {id: new Uint8Array([0x15, 0x49, 0xA9, 0x66]), positionEBML: null},\n                    Tracks: {id: new Uint8Array([0x16, 0x54, 0xAE, 0x6B]), positionEBML: null},\n                },\n                \n                ebmlSegment, // Root element of the EBML document\n                \n                segmentDuration = {\n                    \"id\": 0x4489, // Duration\n                    \"data\": new EBMLFloat64(0)\n                },\n                \n                seekHead,\n                \n                cues = [],\n                \n                blobBuffer = new BlobBuffer(options.fileWriter || options.fd);\n    \n            function fileOffsetToSegmentRelative(fileOffset) {\n                return fileOffset - ebmlSegment.dataOffset;\n            }\n    \n            /**\n             * Extracts the transparency channel from the supplied canvas and uses it to create a VP8 alpha channel bitstream.\n             *\n             * @param {HTMLCanvasElement} source\n             *\n             * @return {HTMLCanvasElement}\n             */\n            function convertAlphaToGrayscaleImage(source) {\n                if (alphaBuffer === null || alphaBuffer.width !== source.width || alphaBuffer.height !== source.height) {\n                    alphaBuffer = document.createElement(\"canvas\");\n                    alphaBuffer.width = source.width;\n                    alphaBuffer.height = source.height;\n                    \n                    alphaBufferContext = alphaBuffer.getContext(\"2d\");\n                    alphaBufferData = alphaBufferContext.createImageData(alphaBuffer.width, alphaBuffer.height);\n                }\n                \n                let\n                    sourceContext = source.getContext(\"2d\"),\n                    sourceData = sourceContext.getImageData(0, 0, source.width, source.height).data,\n                    destData = alphaBufferData.data,\n                    dstCursor = 0,\n                    srcEnd = source.width * source.height * 4;\n                \n                for (let srcCursor = 3 /* Since pixel byte order is RGBA */; srcCursor < srcEnd; srcCursor += 4) {\n                    let\n                        alpha = sourceData[srcCursor];\n                    \n                    // Turn the original alpha channel into a brightness value (ends up being the Y in YUV)\n                    destData[dstCursor++] = alpha;\n                    destData[dstCursor++] = alpha;\n                    destData[dstCursor++] = alpha;\n                    destData[dstCursor++] = 255;\n                }\n                \n                alphaBufferContext.putImageData(alphaBufferData, 0, 0);\n                \n                return alphaBuffer;\n            }\n            \n            /**\n             * Create a SeekHead element with descriptors for the points in the global seekPoints array.\n             *\n             * 5 bytes of position values are reserved for each node, which lie at the offset point.positionEBML.dataOffset,\n             * to be overwritten later.\n             */\n            function createSeekHead() {\n                let\n                    seekPositionEBMLTemplate = {\n                        \"id\": 0x53AC, // SeekPosition\n                        \"size\": 5, // Allows for 32GB video files\n                        \"data\": 0 // We'll overwrite this when the file is complete\n                    },\n                    \n                    result = {\n                        \"id\": 0x114D9B74, // SeekHead\n                        \"data\": []\n                    };\n                \n                for (let name in seekPoints) {\n                    let\n                        seekPoint = seekPoints[name];\n                \n                    seekPoint.positionEBML = Object.create(seekPositionEBMLTemplate);\n                    \n                    result.data.push({\n                         \"id\": 0x4DBB, // Seek\n                         \"data\": [\n                              {\n                                  \"id\": 0x53AB, // SeekID\n                                  \"data\": seekPoint.id\n                              },\n                              seekPoint.positionEBML\n                         ]\n                    });\n                }\n                \n                return result;\n            }\n            \n            /**\n             * Write the WebM file header to the stream.\n             */\n            function writeHeader() {\n                seekHead = createSeekHead();\n                \n                let\n                    ebmlHeader = {\n                        \"id\": 0x1a45dfa3, // EBML\n                        \"data\": [\n                            {\n                                \"id\": 0x4286, // EBMLVersion\n                                \"data\": 1\n                            },\n                            {\n                                \"id\": 0x42f7, // EBMLReadVersion\n                                \"data\": 1\n                            },\n                            {\n                                \"id\": 0x42f2, // EBMLMaxIDLength\n                                \"data\": 4\n                            },\n                            {\n                                \"id\": 0x42f3, // EBMLMaxSizeLength\n                                \"data\": 8\n                            },\n                            {\n                                \"id\": 0x4282, // DocType\n                                \"data\": \"webm\"\n                            },\n                            {\n                                \"id\": 0x4287, // DocTypeVersion\n                                \"data\": 2\n                            },\n                            {\n                                \"id\": 0x4285, // DocTypeReadVersion\n                                \"data\": 2\n                            }\n                        ]\n                    },\n                    \n                    segmentInfo = {\n                        \"id\": 0x1549a966, // Info\n                        \"data\": [\n                            {\n                                \"id\": 0x2ad7b1, // TimecodeScale\n                                \"data\": 1e6 // Times will be in miliseconds (1e6 nanoseconds per step = 1ms)\n                            },\n                            {\n                                \"id\": 0x4d80, // MuxingApp\n                                \"data\": \"webm-writer-js\",\n                            },\n                            {\n                                \"id\": 0x5741, // WritingApp\n                                \"data\": \"webm-writer-js\"\n                            },\n                            segmentDuration // To be filled in later\n                        ]\n                    },\n                    \n                    videoProperties = [\n                        {\n                            \"id\": 0xb0, // PixelWidth\n                            \"data\": videoWidth\n                        },\n                        {\n                            \"id\": 0xba, // PixelHeight\n                            \"data\": videoHeight\n                        }\n                    ];\n                \n                if (options.transparent) {\n                    videoProperties.push(\n                        {\n                            \"id\": 0x53C0, // AlphaMode\n                            \"data\": 1\n                        }\n                    );\n                }\n                \n                let\n                    tracks = {\n                        \"id\": 0x1654ae6b, // Tracks\n                        \"data\": [\n                            {\n                                \"id\": 0xae, // TrackEntry\n                                \"data\": [\n                                    {\n                                        \"id\": 0xd7, // TrackNumber\n                                        \"data\": DEFAULT_TRACK_NUMBER\n                                    },\n                                    {\n                                        \"id\": 0x73c5, // TrackUID\n                                        \"data\": DEFAULT_TRACK_NUMBER\n                                    },\n                                    {\n                                        \"id\": 0x9c, // FlagLacing\n                                        \"data\": 0\n                                    },\n                                    {\n                                        \"id\": 0x22b59c, // Language\n                                        \"data\": \"und\"\n                                    },\n                                    {\n                                        \"id\": 0x86, // CodecID\n                                        \"data\": \"V_VP8\"\n                                    },\n                                    {\n                                        \"id\": 0x258688, // CodecName\n                                        \"data\": \"VP8\"\n                                    },\n                                    {\n                                        \"id\": 0x83, // TrackType\n                                        \"data\": 1\n                                    },\n                                    {\n                                        \"id\": 0xe0,  // Video\n                                        \"data\": videoProperties\n                                    }\n                                ]\n                            }\n                        ]\n                    };\n                \n                ebmlSegment = {\n                    \"id\": 0x18538067, // Segment\n                    \"size\": EBML_SIZE_UNKNOWN_5_BYTES, // We'll seek back and fill this in at completion\n                    \"data\": [\n                        seekHead,\n                        segmentInfo,\n                        tracks,\n                    ]\n                };\n                \n                let\n                    bufferStream = new ArrayBufferDataStream(256);\n                    \n                writeEBML(bufferStream, blobBuffer.pos, [ebmlHeader, ebmlSegment]);\n                blobBuffer.write(bufferStream.getAsDataArray());\n                \n                // Now we know where these top-level elements lie in the file:\n                seekPoints.SegmentInfo.positionEBML.data = fileOffsetToSegmentRelative(segmentInfo.offset);\n                seekPoints.Tracks.positionEBML.data = fileOffsetToSegmentRelative(tracks.offset);\n                \n\t            writtenHeader = true;\n            }\n    \n            /**\n             * Create a BlockGroup element to hold the given keyframe (used when alpha support is required)\n             *\n             * @param {Frame} keyframe\n             *\n             * @return A BlockGroup EBML element\n             */\n            function createBlockGroupForTransparentKeyframe(keyframe) {\n                let\n                    block, blockAdditions,\n                    \n                    bufferStream = new ArrayBufferDataStream(1 + 2 + 1);\n    \n                // Create a Block to hold the image data:\n                \n                if (!(keyframe.trackNumber > 0 && keyframe.trackNumber < 127)) {\n                    throw new Error(\"TrackNumber must be > 0 and < 127\");\n                }\n        \n                bufferStream.writeEBMLVarInt(keyframe.trackNumber); // Always 1 byte since we limit the range of trackNumber\n                bufferStream.writeU16BE(keyframe.timecode);\n                bufferStream.writeByte(0); // Flags byte\n    \n                block = {\n                    \"id\": 0xA1, // Block\n                    \"data\": [\n                        bufferStream.getAsDataArray(),\n                        keyframe.frame\n                    ]\n                };\n    \n                blockAdditions = {\n                    \"id\": 0x75A1, // BlockAdditions\n                    \"data\": [\n                        {\n                            \"id\": 0xA6, // BlockMore\n                            \"data\": [\n                                {\n                                    \"id\": 0xEE, // BlockAddID\n                                    \"data\": 1   // Means \"BlockAdditional has a codec-defined meaning, pass it to the codec\"\n                                },\n                                {\n                                    \"id\": 0xA5, // BlockAdditional\n                                    \"data\": keyframe.alpha // The actual alpha channel image\n                                }\n                            ]\n                        }\n                    ]\n                };\n    \n                return {\n                    \"id\": 0xA0, // BlockGroup\n                    \"data\": [\n                        block,\n                        blockAdditions\n                    ]\n                };\n            }\n            \n            /**\n             * Create a SimpleBlock element to hold the given keyframe.\n             *\n             * @param {Frame} keyframe\n             *\n             * @return A SimpleBlock EBML element.\n             */\n            function createSimpleBlockForKeyframe(keyframe) {\n                let\n                    bufferStream = new ArrayBufferDataStream(1 + 2 + 1);\n                \n                if (!(keyframe.trackNumber > 0 && keyframe.trackNumber < 127)) {\n                    throw new Error(\"TrackNumber must be > 0 and < 127\");\n                }\n    \n                bufferStream.writeEBMLVarInt(keyframe.trackNumber); // Always 1 byte since we limit the range of trackNumber\n                bufferStream.writeU16BE(keyframe.timecode);\n                \n                // Flags byte\n                bufferStream.writeByte(\n                    1 << 7 // Keyframe\n                );\n                \n                return {\n                    \"id\": 0xA3, // SimpleBlock\n                    \"data\": [\n                         bufferStream.getAsDataArray(),\n                         keyframe.frame\n                    ]\n                };\n            }\n    \n            /**\n             * Create either a SimpleBlock or BlockGroup (if alpha is required) for the given keyframe.\n             *\n             * @param {Frame} keyframe\n             */\n            function createContainerForKeyframe(keyframe) {\n                if (keyframe.alpha) {\n                    return createBlockGroupForTransparentKeyframe(keyframe);\n                }\n                \n                return createSimpleBlockForKeyframe(keyframe);\n            }\n        \n            /**\n             * Create a Cluster EBML node.\n             *\n             * @param {Cluster} cluster\n             *\n             * Returns an EBML element.\n             */\n            function createCluster(cluster) {\n                return {\n                    \"id\": 0x1f43b675,\n                    \"data\": [\n                         {\n                            \"id\": 0xe7, // Timecode\n                            \"data\": Math.round(cluster.timecode)\n                         }\n                    ]\n                };\n            }\n            \n            function addCuePoint(trackIndex, clusterTime, clusterFileOffset) {\n                cues.push({\n                    \"id\": 0xBB, // Cue\n                    \"data\": [\n                         {\n                             \"id\": 0xB3, // CueTime\n                             \"data\": clusterTime\n                         },\n                         {\n                             \"id\": 0xB7, // CueTrackPositions\n                             \"data\": [\n                                  {\n                                      \"id\": 0xF7, // CueTrack\n                                      \"data\": trackIndex\n                                  },\n                                  {\n                                      \"id\": 0xF1, // CueClusterPosition\n                                      \"data\": fileOffsetToSegmentRelative(clusterFileOffset)\n                                  }\n                             ]\n                         }\n                    ]\n                });\n            }\n            \n            /**\n             * Write a Cues element to the blobStream using the global `cues` array of CuePoints (use addCuePoint()).\n             * The seek entry for the Cues in the SeekHead is updated.\n             */\n            function writeCues() {\n                let\n                    ebml = {\n                        \"id\": 0x1C53BB6B,\n                        \"data\": cues\n                    },\n                    \n                    cuesBuffer = new ArrayBufferDataStream(16 + cues.length * 32); // Pretty crude estimate of the buffer size we'll need\n                \n                writeEBML(cuesBuffer, blobBuffer.pos, ebml);\n                blobBuffer.write(cuesBuffer.getAsDataArray());\n                \n                // Now we know where the Cues element has ended up, we can update the SeekHead\n                seekPoints.Cues.positionEBML.data = fileOffsetToSegmentRelative(ebml.offset);\n            }\n            \n            /**\n             * Flush the frames in the current clusterFrameBuffer out to the stream as a Cluster.\n             */\n            function flushClusterFrameBuffer() {\n                if (clusterFrameBuffer.length === 0) {\n                    return;\n                }\n    \n                // First work out how large of a buffer we need to hold the cluster data\n                let\n                    rawImageSize = 0;\n                \n                for (let i = 0; i < clusterFrameBuffer.length; i++) {\n                    rawImageSize += clusterFrameBuffer[i].frame.length + (clusterFrameBuffer[i].alpha ? clusterFrameBuffer[i].alpha.length : 0);\n                }\n                \n                let\n                    buffer = new ArrayBufferDataStream(rawImageSize + clusterFrameBuffer.length * 64), // Estimate 64 bytes per block header\n    \n                    cluster = createCluster({\n                        timecode: Math.round(clusterStartTime),\n                    });\n                \n                for (let i = 0; i < clusterFrameBuffer.length; i++) {\n                    cluster.data.push(createContainerForKeyframe(clusterFrameBuffer[i]));\n                }\n                \n                writeEBML(buffer, blobBuffer.pos, cluster);\n                blobBuffer.write(buffer.getAsDataArray());\n                \n                addCuePoint(DEFAULT_TRACK_NUMBER, Math.round(clusterStartTime), cluster.offset);\n                \n                clusterFrameBuffer = [];\n                clusterStartTime += clusterDuration;\n                clusterDuration = 0;\n            }\n            \n            function validateOptions() {\n                // Derive frameDuration setting if not already supplied\n                if (!options.frameDuration) {\n                    if (options.frameRate) {\n                        options.frameDuration = 1000 / options.frameRate;\n                    } else {\n                        throw new Error(\"Missing required frameDuration or frameRate setting\");\n                    }\n                }\n                \n                // Avoid 1.0 (lossless) because it creates VP8L lossless frames that WebM doesn't support\n                options.quality = Math.max(Math.min(options.quality, 0.99999), 0);\n                \n                if (options.alphaQuality === undefined) {\n                    options.alphaQuality = options.quality;\n                } else {\n                    options.alphaQuality = Math.max(Math.min(options.alphaQuality, 0.99999), 0);\n                }\n            }\n    \n            /**\n             *\n             * @param {Frame} frame\n             */\n            function addFrameToCluster(frame) {\n                frame.trackNumber = DEFAULT_TRACK_NUMBER;\n                \n                // Frame timecodes are relative to the start of their cluster:\n                frame.timecode = Math.round(clusterDuration);\n    \n                clusterFrameBuffer.push(frame);\n                \n                clusterDuration += frame.duration;\n                \n                if (clusterDuration >= MAX_CLUSTER_DURATION_MSEC) {\n                    flushClusterFrameBuffer();\n                }\n            }\n            \n            /**\n             * Rewrites the SeekHead element that was initially written to the stream with the offsets of top level elements.\n             *\n             * Call once writing is complete (so the offset of all top level elements is known).\n             */\n            function rewriteSeekHead() {\n                let\n                    seekHeadBuffer = new ArrayBufferDataStream(seekHead.size),\n                    oldPos = blobBuffer.pos;\n                \n                // Write the rewritten SeekHead element's data payload to the stream (don't need to update the id or size)\n                writeEBML(seekHeadBuffer, seekHead.dataOffset, seekHead.data);\n                \n                // And write that through to the file\n                blobBuffer.seek(seekHead.dataOffset);\n                blobBuffer.write(seekHeadBuffer.getAsDataArray());\n    \n                blobBuffer.seek(oldPos);\n            }\n            \n            /**\n             * Rewrite the Duration field of the Segment with the newly-discovered video duration.\n             */\n            function rewriteDuration() {\n                let\n                    buffer = new ArrayBufferDataStream(8),\n                    oldPos = blobBuffer.pos;\n                \n                // Rewrite the data payload (don't need to update the id or size)\n                buffer.writeDoubleBE(clusterStartTime);\n                \n                // And write that through to the file\n                blobBuffer.seek(segmentDuration.dataOffset);\n                blobBuffer.write(buffer.getAsDataArray());\n        \n                blobBuffer.seek(oldPos);\n            }\n    \n            /**\n             * Rewrite the size field of the Segment.\n             */\n            function rewriteSegmentLength() {\n                let\n                    buffer = new ArrayBufferDataStream(10),\n                    oldPos = blobBuffer.pos;\n    \n                // We just need to rewrite the ID and Size fields of the root Segment:\n                buffer.writeUnsignedIntBE(ebmlSegment.id);\n                buffer.writeEBMLVarIntWidth(blobBuffer.pos - ebmlSegment.dataOffset, 5);\n                \n                // And write that on top of the original:\n                blobBuffer.seek(ebmlSegment.offset);\n                blobBuffer.write(buffer.getAsDataArray());\n        \n                blobBuffer.seek(oldPos);\n            }\n            \n            /**\n             * Add a frame to the video.\n             *\n             * @param {HTMLCanvasElement|String} frame - A Canvas element that contains the frame, or a WebP string\n             *                                           you obtained by calling toDataUrl() on an image yourself.\n             *\n             * @param {HTMLCanvasElement|String} [alpha] - For transparent video, instead of including the alpha channel\n             *                                             in your provided `frame`, you can instead provide it separately\n             *                                             here. The alpha channel of this alpha canvas will be ignored,\n             *                                             encode your alpha information into this canvas' grayscale\n             *                                             brightness instead.\n             *\n             *                                             This is useful because it allows you to paint the colours\n             *                                             you need into your `frame` even in regions which are fully\n             *                                             transparent (which Canvas doesn't normally let you influence).\n             *                                             This allows you to control the colour of the fringing seen\n             *                                             around objects on transparent backgrounds.\n             *\n             * @param {Number} [overrideFrameDuration] - Set a duration for this frame (in milliseconds) that differs\n             *                                           from the default\n             */\n            this.addFrame = function(frame, alpha, overrideFrameDuration) {\n                if (!writtenHeader) {\n                    videoWidth = frame.width || 0;\n                    videoHeight = frame.height || 0;\n    \n                    writeHeader();\n                }\n    \n                let\n                    keyframe = extractKeyframeFromWebP(renderAsWebP(frame, options.quality)),\n                    frameDuration, frameAlpha = null;\n                \n                if (overrideFrameDuration) {\n                    frameDuration = overrideFrameDuration;\n                } else if (typeof alpha == \"number\") {\n                    frameDuration = alpha;\n                } else {\n                    frameDuration = options.frameDuration;\n                }\n                \n                if (options.transparent) {\n                    if (alpha instanceof HTMLCanvasElement || typeof alpha === \"string\") {\n                        frameAlpha = alpha;\n                    } else if (keyframe.hasAlpha) {\n                        frameAlpha = convertAlphaToGrayscaleImage(frame);\n                    }\n                }\n                \n                addFrameToCluster({\n                    frame: keyframe.frame,\n                    duration: frameDuration,\n                    alpha: frameAlpha ? extractKeyframeFromWebP(renderAsWebP(frameAlpha, options.alphaQuality)).frame : null\n                });\n            };\n            \n            /**\n             * Finish writing the video and return a Promise to signal completion.\n             *\n             * If the destination device was memory (i.e. options.fileWriter was not supplied), the Promise is resolved with\n             * a Blob with the contents of the entire video.\n             */\n            this.complete = function() {\n            \tif (!writtenHeader) {\n\t\t            writeHeader();\n\t            }\n\t            \n                flushClusterFrameBuffer();\n                writeCues();\n                \n                /* \n                 * Now the file is at its final length and the position of all elements is known, seek back to the\n                 * header and update pointers:\n                 */\n                \n                rewriteSeekHead();\n                rewriteDuration();\n                rewriteSegmentLength();\n                \n                return blobBuffer.complete('video/webm');\n            };\n            \n            this.getWrittenSize = function() {\n                return blobBuffer.length;\n            };\n    \n            options = extend(optionDefaults, options || {});\n            validateOptions();\n        };\n    };\n    \n    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n\t    module.exports = WebMWriter;\n    } else {\n\t    window.WebMWriter = WebMWriter(window.ArrayBufferDataStream, window.BlobBuffer);\n    }\n})();\n"],"names":[],"version":3,"file":"index.0755f3fd.js.map","sourceRoot":"/__parcel_source_root/"}
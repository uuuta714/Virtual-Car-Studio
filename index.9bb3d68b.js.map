{"mappings":"C,A,S,C,C,C,C,C,C,C,C,C,E,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,A,Y,O,C,C,E,E,C,C,E,C,E,E,K,E,C,E,E,A,a,O,Q,A,Y,O,O,O,E,O,O,C,I,C,Q,S,E,C,C,C,E,G,C,C,C,E,C,C,G,C,C,C,E,C,C,I,E,A,Y,O,C,C,E,E,C,C,E,C,G,C,G,E,O,E,E,C,G,G,E,O,E,E,C,G,G,G,A,U,O,E,O,E,G,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,O,C,S,C,E,I,E,C,C,E,C,E,C,E,C,O,A,M,E,E,C,E,E,K,C,C,E,I,E,C,C,E,C,I,E,M,C,G,C,C,E,C,E,C,I,C,E,O,C,E,E,E,O,C,I,C,C,O,C,C,E,C,O,C,S,E,C,E,I,E,E,O,C,G,M,A,C,I,E,C,E,E,E,C,C,E,e,C,C,E,E,M,C,S,C,E,I,C,E,C,E,I,C,M,C,E,I,C,O,C,C,C,E,E,O,C,E,E,K,C,E,E,M,C,E,E,Q,C,S,C,C,C,E,C,C,E,C,C,S,C,C,C,E,E,O,C,C,E,C,E,A,E,O,c,C,E,O,C,I,W,O,C,C,E,A,C,G,C,C,E,C,E,I,I,E,E,E,E,M,C,I,E,C,C,E,E,G,E,C,I,E,E,E,A,C,U,O,S,A,a,O,O,O,O,C,E,Y,O,Q,O,G,E,O,W,O,C,E,C,E,C,Q,C,S,C,C,C,C,C,E,I,E,E,kD,E,iB,C,GCuUA,EAAA,MAAA,CAAA,EAAA,4BAAA,IAAgB,GAvUhB,IAAA,EAAA,EAAA,SAEA,EAAA,EAAA,gBAcA,SAAS,cAAc,CAAC,wBAAwB,gBAAgB,CAAC,QAAS,WAEtE,AAiRJ,CAAA,SAA8B,CAAK,EAC/B,GAAI,AAAA,CAAA,EAAA,EAAA,WAAU,AAAV,CAAW,CAAC,EAAM,CAAC,IAAI,CAAC,UAAU,CAAC,gBAAiB,CAEpD,IAAM,EAAY,WAAW,AADN,SAAS,cAAc,CAAC,kBACH,KAAK,EACjD,AAAA,CAAA,EAAA,EAAA,WAAW,AAAX,CAAW,CAAC,EAAM,CAAC,QAAQ,CAAC,AAAC,IACzB,GAAI,EAAM,MAAM,EACR,AAAc,YAAd,EAAM,IAAI,CAAgB,CAC1B,IAAM,EAAa,EAAM,QA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","sources":["<anon>","src/js/lighting.js"],"sourcesContent":["// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (modules, entry, mainEntry, parcelRequireName, globalName) {\n  /* eslint-disable no-undef */\n  var globalObject =\n    typeof globalThis !== 'undefined'\n      ? globalThis\n      : typeof self !== 'undefined'\n      ? self\n      : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {};\n  /* eslint-enable no-undef */\n\n  // Save the require from previous bundle to this closure if any\n  var previousRequire =\n    typeof globalObject[parcelRequireName] === 'function' &&\n    globalObject[parcelRequireName];\n\n  var cache = previousRequire.cache || {};\n  // Do not use `require` to prevent Webpack from trying to bundle this call\n  var nodeRequire =\n    typeof module !== 'undefined' &&\n    typeof module.require === 'function' &&\n    module.require.bind(module);\n\n  function newRequire(name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        // if we cannot find the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire =\n          typeof globalObject[parcelRequireName] === 'function' &&\n          globalObject[parcelRequireName];\n        if (!jumped && currentRequire) {\n          return currentRequire(name, true);\n        }\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) {\n          return previousRequire(name, true);\n        }\n\n        // Try the node require function if it exists.\n        if (nodeRequire && typeof name === 'string') {\n          return nodeRequire(name);\n        }\n\n        var err = new Error(\"Cannot find module '\" + name + \"'\");\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n      }\n\n      localRequire.resolve = resolve;\n      localRequire.cache = {};\n\n      var module = (cache[name] = new newRequire.Module(name));\n\n      modules[name][0].call(\n        module.exports,\n        localRequire,\n        module,\n        module.exports,\n        this\n      );\n    }\n\n    return cache[name].exports;\n\n    function localRequire(x) {\n      var res = localRequire.resolve(x);\n      return res === false ? {} : newRequire(res);\n    }\n\n    function resolve(x) {\n      var id = modules[name][1][x];\n      return id != null ? id : x;\n    }\n  }\n\n  function Module(moduleName) {\n    this.id = moduleName;\n    this.bundle = newRequire;\n    this.exports = {};\n  }\n\n  newRequire.isParcelRequire = true;\n  newRequire.Module = Module;\n  newRequire.modules = modules;\n  newRequire.cache = cache;\n  newRequire.parent = previousRequire;\n  newRequire.register = function (id, exports) {\n    modules[id] = [\n      function (require, module) {\n        module.exports = exports;\n      },\n      {},\n    ];\n  };\n\n  Object.defineProperty(newRequire, 'root', {\n    get: function () {\n      return globalObject[parcelRequireName];\n    },\n  });\n\n  globalObject[parcelRequireName] = newRequire;\n\n  for (var i = 0; i < entry.length; i++) {\n    newRequire(entry[i]);\n  }\n\n  if (mainEntry) {\n    // Expose entry point to Node, AMD or browser globals\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\n    var mainExports = newRequire(mainEntry);\n\n    // CommonJS\n    if (typeof exports === 'object' && typeof module !== 'undefined') {\n      module.exports = mainExports;\n\n      // RequireJS\n    } else if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return mainExports;\n      });\n\n      // <script>\n    } else if (globalName) {\n      this[globalName] = mainExports;\n    }\n  }\n})({\"7w0Le\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\n// Function to populate the studio light dropdown menu\nparcelHelpers.export(exports, \"updateStudioLightDropdown\", ()=>updateStudioLightDropdown);\nvar _three = require(\"three\");\nvar _scriptsJs = require(\"./scripts.js\");\n// Event listener for applying intensity and color change\ndocument.getElementById(\"applyIntensityButton\").addEventListener(\"click\", function() {\n    const selectedLightIndex = parseInt(document.getElementById(\"lightInstanceDropdown\").value);\n    applyIntensityChange(selectedLightIndex);\n});\ndocument.getElementById(\"applyColorButton\").addEventListener(\"click\", function() {\n    const selectedLightIndex = parseInt(document.getElementById(\"lightInstanceDropdown\").value);\n    applyColorChange(selectedLightIndex);\n});\n// Event listener for deleting light instance\ndocument.getElementById(\"deleteLightButton\").addEventListener(\"click\", function() {\n    const selectedLightIndex = parseInt(document.getElementById(\"lightInstanceDropdown\").value);\n    deleteLightInstance(selectedLightIndex);\n    updateStudioLightDropdown();\n});\n// Event listener for adding light instance\ndocument.getElementById(\"addLightButton\").addEventListener(\"click\", function() {\n    const selectedLightIndex = parseInt(document.getElementById(\"lightInstanceDropdown\").value);\n    console.log(selectedLightIndex);\n    (0, _scriptsJs.setSelectedIndex)(selectedLightIndex);\n    console.log((0, _scriptsJs.selectedIndex));\n    createLightInstance();\n    updateStudioLightDropdown();\n});\n// // import {\n// //     openSlideOut,\n// //     closeSlideOut\n// // } from './userInteractions.js'\n// let selectedObject;\n// // Raycaster\n// const raycaster = new THREE.Raycaster();\n// const mouse = new THREE.Vector2();\n// // Function for mouse control\n// export function onDocumentMouseDown(event) {\n//     // Implementation of mouse down interactions\n//     const slideOutElement = document.getElementById('lighting-content');\n//     // Get the bounding rectangle of the slide-out element\n//     const rect = slideOutElement.getBoundingClientRect();\n//     // Check if the mouse event is within the slide-out element\n//     if (\n//         event.clientX >= rect.left &&\n//         event.clientX <= rect.right &&\n//         event.clientY >= rect.top &&\n//         event.clientY <= rect.bottom\n//     ) {\n//         // ignore the click if it was inside the slide-out element and apply the parameterised control\n//         // Event listener for applying intensity and color change\n//         document.getElementById(\"applyIntensityButton\").addEventListener(\"click\", applyIntensityChange(selectedIndex));\n//         document.getElementById(\"applyColorButton\").addEventListener(\"click\", applyColorChange(selectedIndex));\n//         // Event listener for deleting light instance\n//         document.getElementById(\"deleteLightButton\").addEventListener(\"click\", deleteLightInstance);\n//         return;\n//     }\n//     var mouse = new THREE.Vector2();\n//     mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;\n// \tmouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;\n//     const raycaster = new THREE.Raycaster();\n//     raycaster.setFromCamera(mouse, camera);\n//     const filteredObjects = scene.children.filter(object => object.name !== 'topLight');\n//     var intersects = raycaster.intersectObjects(filteredObjects, true);\n//     if (intersects.length > 0) {\n// \t\tlet hit = intersects[0].object;\n//         if (intersects.length) {\n//             // locate the object from the 10 closest intersections\n//             for (let i = 0; i < intersects.length; i++) {\n//                 let current = intersects[i].object;\n//                 if (current.isMesh) {\n//                     // traverse to the parent to move the whole object\n//                     while (current.parent.parent !== null) {\n//                     current = current.parent;\n//                     }\n//                     hit = current;\n//                 }\n//                 break;\n//             }\n//         if (hit.name in objects) {\n//             if (selectedObject != objects[hit.name]) {\n//                 selectedObject = objects[hit.name];\n//                 console.log(`Selected ${hit.name}`);\n// \t\t\t\topenSlideOut();\n//             } else {\n//                 console.log(`${hit.name} is already selected`);\n//             }\n//         } else {\n//             if (selectedObject) {\n//                 // Move selected object to the hit point if needed\n//                 var pos = intersects[0].point;\n//                 // collision control to be implemented\n//                 if (true) {\n//                     selectedObject.model.position.x = pos.x;\n//                     selectedObject.model.position.z = pos.z;\n//                     selectedObject.box.setFromObject(selectedObject.model);\n//                     console.log(`Moved ${selectedObject.model.name} to new position without collision.`);\n//                 } else {\n//                     console.log(`Move blocked due to potential collision.`);\n//                 }\n//             }\n//         }\n//     } else {\n//         selectedObject = null; // Deselect any selected object\n//     }\n//   }\n// }\n// // function to check collisions\n// function checkForCollisions(objectData, newPosition) {\n//     let tempBox = new THREE.Box3().copy(objectData.box);  // Copy the existing box\n//     tempBox.setFromObject(objectData.model);  // Update to the new position temporarily\n//     tempBox.translate(new THREE.Vector3(newPosition.x - objectData.model.position.x, 0, newPosition.z - objectData.model.position.z));\n//     for (let key in objects) {\n//         if (objects[key] !== objectData && tempBox.intersectsBox(objects[key].box)) {\n//             console.log(`Collision detected with ${key}`);\n//             return true;  // Collision detected\n//         }\n//     }\n//     return false;  // No collision\n// }\n// let controls;\n// export function onDocumentKeyDown(event) {\n//     // Implementation of key down interactions\n//     if (selectedObject) {\n//         switch (event.key) {\n//             case \"ArrowRight\":\n//                 moveObject(selectedObject, 'right');\n//                 break;\n//             case \"ArrowLeft\":\n//                 moveObject(selectedObject, 'left');\n//                 break;\n//             case \"ArrowUp\":\n//                 moveObject(selectedObject, 'forward');\n//                 break;\n//             case \"ArrowDown\":\n//                 moveObject(selectedObject, 'backward');\n//                 break;\n//             case \"Escape\":\n//                 selectedObject = null;\n//                 console.log(\"deselected\");\n//                 break;\n//             case \"l\":\n//                 rotateObject(selectedObject, 4);\n//                 break;\n//         }\n//     }\n//   }\n// function moveObject(object, direction) {\n//     const distance = 0.25; // Distance to move in each step, adjust as needed\n//     switch (direction) {\n//         case 'left':\n//             object.model.position.x += distance;\n//             break;\n//         case 'right':\n//             object.model.position.x -= distance;\n//             break;\n//         case 'backward':\n//             object.model.position.z -= distance;\n//             break;\n//         case 'forward':\n//             object.model.position.z += distance;\n//             break;\n//     }\n//     object.box.setFromObject(object.model);  // Update the bounding box\n//   }\n// function rotateObject(object, angleInDegrees) {\n//   const angleInRadians = angleInDegrees * Math.PI / 180;\n//   object.model.rotation.y += angleInRadians;  // Rotate around the y-axis\n//   object.box.setFromObject(object.model);  // Update the bounding box\n// }\nlet cloneCounter = 1;\n// Define a function to create new instance of the light\nfunction createLightInstance() {\n    // Clone the model to create a new instance\n    let model;\n    if ((0, _scriptsJs.modelGroups)[0, _scriptsJs.selectedIndex].name.startsWith(\"studio_light\")) model = (0, _scriptsJs.modelGroups)[0, _scriptsJs.selectedIndex];\n    else model = (0, _scriptsJs.modelGroups).find((group)=>group.name.startsWith(\"studio_light\"));\n    model.rotation.set(0, 0, 0);\n    const newModel = model.clone(true);\n    newModel.traverse((node)=>{\n        if (node.isMesh) node.material = node.material.clone();\n    });\n    newModel.name = \"studio_light \" + cloneCounter++;\n    // Adjust position, scale, or any other properties if needed\n    // For example:\n    newModel.position.set(1, 0, -5);\n    // Add the new instance to the scene\n    (0, _scriptsJs.scene).add(newModel);\n    // Compute the bounding box to get size\n    const boundingBox = new _three.Box3().setFromObject(newModel);\n    const size = new _three.Vector3();\n    boundingBox.getSize(size);\n    // Create BoxGeometry based on the computed size\n    const modelDragBox = new _three.Mesh(new _three.BoxGeometry(size.x, size.y, size.z), new _three.MeshBasicMaterial({\n        transparent: true,\n        opacity: 0\n    }));\n    modelDragBox.position.copy(newModel.position);\n    modelDragBox.userData.originalY = modelDragBox.position.y += size.y / 2;\n    (0, _scriptsJs.scene).add(modelDragBox);\n    const boxHelper = new _three.BoxHelper(modelDragBox, 0xffff00);\n    boxHelper.visible = false;\n    (0, _scriptsJs.scene).add(boxHelper);\n    (0, _scriptsJs.modelGroups).push(newModel);\n    (0, _scriptsJs.sceneMeshes).push(modelDragBox);\n    (0, _scriptsJs.modelDragBoxes).push(modelDragBox);\n    (0, _scriptsJs.boxHelpers).push(boxHelper);\n}\n// Function to delete the selected light instance\nfunction deleteLightInstance(index) {\n    if ((0, _scriptsJs.modelGroups)[index].name.startsWith(\"studio_light\")) {\n        (0, _scriptsJs.scene).remove((0, _scriptsJs.modelGroups)[index]);\n        (0, _scriptsJs.modelGroups).splice(index, 1);\n        (0, _scriptsJs.sceneMeshes).splice(index, 1);\n        (0, _scriptsJs.boxHelpers).splice(index, 1);\n        (0, _scriptsJs.modelDragBoxes).splice(index, 1);\n        (0, _scriptsJs.setSelectedIndex)(0);\n    }\n}\n// Event listener for moving objects\n// document.addEventListener('mousedown', onDocumentMouseDown);\n// document.addEventListener('keydown', onDocumentKeyDown);\n// // Event listener for opening lighting control slideout\n// document.getElementById(\"openButton\").addEventListener(\"click\", openSlideOut);\n// document.getElementById(\"closeButton\").addEventListener(\"click\", closeSlideOut);\n// // Event listener for opening lighting control slideout\n// document.getElementById(\"openButton\").addEventListener(\"click\", openSlideOut);\n// document.getElementById(\"closeButton\").addEventListener(\"click\", closeSlideOut);\n// Control the lighting control slideout\n// export function openSlideOut() {\n//     document.getElementById(\"rightSlideout\").style.right = \"0\";\n// }\n// export function openSlideOut() {\n//     document.getElementById(\"rightSlideout\").style.right = \"0\";\n// }\n// export function closeSlideOut() {\n//     document.getElementById(\"rightSlideout\").style.right = \"-250px\";\n// }\n// Function to apply intensity change - Updated\nfunction applyIntensityChange(index) {\n    if ((0, _scriptsJs.modelGroups)[index].name.startsWith(\"studio_light\")) {\n        const intensityInput = document.getElementById(\"intensityInput\");\n        const intensity = parseFloat(intensityInput.value);\n        (0, _scriptsJs.modelGroups)[index].traverse((child)=>{\n            if (child.isMesh) {\n                if (child.name == \"Object_7\") {\n                    const pointLight = child.children[0];\n                    if (!isNaN(intensity)) pointLight.intensity = intensity;\n                }\n            }\n        });\n    }\n}\n// Function to apply color change - Updated\nfunction applyColorChange(index) {\n    if ((0, _scriptsJs.modelGroups)[index].name.startsWith(\"studio_light\")) {\n        const colorPicker = document.getElementById(\"colorPicker\");\n        const color = new _three.Color(colorPicker.value);\n        (0, _scriptsJs.modelGroups)[index].traverse((child)=>{\n            if (child.isMesh) {\n                if (child.name == \"Object_7\") {\n                    const pointLight = child.children[0];\n                    pointLight.color = color;\n                    console.log(\"found\");\n                    child.material.emissive.set(color);\n                }\n            }\n        });\n    }\n}\nfunction updateStudioLightDropdown() {\n    const dropdown = document.getElementById(\"lightInstanceDropdown\");\n    dropdown.innerHTML = '<option value=\"\">Select a Light Instance</option>'; // Clear previous options\n    (0, _scriptsJs.modelGroups).forEach((modelGroup, index)=>{\n        if (modelGroup.name.startsWith(\"studio_light\")) {\n            const optionElement = document.createElement(\"option\");\n            optionElement.value = index;\n            optionElement.textContent = modelGroup.name;\n            dropdown.appendChild(optionElement);\n        }\n    });\n}\n\n},{\"three\":\"35GVu\",\"./scripts.js\":\"f5JPT\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"k3151\"}]},[\"7w0Le\"], \"7w0Le\", \"parcelRequire6fcf\")\n\n//# sourceMappingURL=index.9bb3d68b.js.map\n","import * as THREE from 'three';\r\nimport { Vector3 } from 'three'\r\nimport {\r\n    renderer,\r\n    camera, \r\n    scene,\r\n    objects,\r\n    selectedIndex,\r\n    setSelectedIndex,\r\n    modelGroups,\r\n    sceneMeshes,\r\n    boxHelpers,\r\n    modelDragBoxes\r\n} from './scripts.js'\r\n\r\n// Event listener for applying intensity and color change\r\ndocument.getElementById(\"applyIntensityButton\").addEventListener(\"click\", function() {\r\n    const selectedLightIndex = parseInt(document.getElementById('lightInstanceDropdown').value);\r\n    applyIntensityChange(selectedLightIndex);\r\n});\r\ndocument.getElementById(\"applyColorButton\").addEventListener(\"click\", function() {\r\n    const selectedLightIndex = parseInt(document.getElementById('lightInstanceDropdown').value);\r\n    applyColorChange(selectedLightIndex);\r\n});\r\n// Event listener for deleting light instance\r\ndocument.getElementById(\"deleteLightButton\").addEventListener(\"click\", function() {\r\n    const selectedLightIndex = parseInt(document.getElementById('lightInstanceDropdown').value);\r\n    deleteLightInstance(selectedLightIndex);\r\n    updateStudioLightDropdown();\r\n});\r\n// Event listener for adding light instance\r\ndocument.getElementById(\"addLightButton\").addEventListener(\"click\", function() {\r\n    const selectedLightIndex = parseInt(document.getElementById('lightInstanceDropdown').value);\r\n    console.log(selectedLightIndex)\r\n    setSelectedIndex(selectedLightIndex);\r\n    console.log(selectedIndex)\r\n    createLightInstance();\r\n    updateStudioLightDropdown();\r\n});\r\n\r\n// // import {\r\n// //     openSlideOut,\r\n// //     closeSlideOut\r\n// // } from './userInteractions.js'\r\n\r\n// let selectedObject;\r\n// // Raycaster\r\n// const raycaster = new THREE.Raycaster();\r\n// const mouse = new THREE.Vector2();\r\n\r\n\r\n// // Function for mouse control\r\n// export function onDocumentMouseDown(event) {\r\n//     // Implementation of mouse down interactions\r\n//     const slideOutElement = document.getElementById('lighting-content');\r\n\r\n//     // Get the bounding rectangle of the slide-out element\r\n//     const rect = slideOutElement.getBoundingClientRect();\r\n\r\n//     // Check if the mouse event is within the slide-out element\r\n//     if (\r\n//         event.clientX >= rect.left &&\r\n//         event.clientX <= rect.right &&\r\n//         event.clientY >= rect.top &&\r\n//         event.clientY <= rect.bottom\r\n//     ) {\r\n//         // ignore the click if it was inside the slide-out element and apply the parameterised control\r\n\r\n//         // Event listener for applying intensity and color change\r\n//         document.getElementById(\"applyIntensityButton\").addEventListener(\"click\", applyIntensityChange(selectedIndex));\r\n//         document.getElementById(\"applyColorButton\").addEventListener(\"click\", applyColorChange(selectedIndex));\r\n//         // Event listener for deleting light instance\r\n//         document.getElementById(\"deleteLightButton\").addEventListener(\"click\", deleteLightInstance);\r\n//         return;\r\n//     }\r\n\r\n//     var mouse = new THREE.Vector2();\r\n//     mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;\r\n// \tmouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;\r\n\r\n//     const raycaster = new THREE.Raycaster();\r\n//     raycaster.setFromCamera(mouse, camera);\r\n//     const filteredObjects = scene.children.filter(object => object.name !== 'topLight');\r\n//     var intersects = raycaster.intersectObjects(filteredObjects, true);\r\n\r\n//     if (intersects.length > 0) {\r\n// \t\tlet hit = intersects[0].object;\r\n   \r\n//         if (intersects.length) {\r\n//             // locate the object from the 10 closest intersections\r\n//             for (let i = 0; i < intersects.length; i++) {\r\n//                 let current = intersects[i].object;\r\n//                 if (current.isMesh) {\r\n//                     // traverse to the parent to move the whole object\r\n//                     while (current.parent.parent !== null) {\r\n//                     current = current.parent;\r\n//                     }\r\n//                     hit = current;\r\n//                 }\r\n//                 break;\r\n//             }\r\n//         if (hit.name in objects) {\r\n//             if (selectedObject != objects[hit.name]) {\r\n//                 selectedObject = objects[hit.name];\r\n//                 console.log(`Selected ${hit.name}`);\r\n// \t\t\t\topenSlideOut();\r\n//             } else {\r\n//                 console.log(`${hit.name} is already selected`);\r\n//             }\r\n//         } else {\r\n//             if (selectedObject) {\r\n//                 // Move selected object to the hit point if needed\r\n//                 var pos = intersects[0].point;\r\n//                 // collision control to be implemented\r\n//                 if (true) {\r\n//                     selectedObject.model.position.x = pos.x;\r\n//                     selectedObject.model.position.z = pos.z;\r\n//                     selectedObject.box.setFromObject(selectedObject.model);\r\n//                     console.log(`Moved ${selectedObject.model.name} to new position without collision.`);\r\n//                 } else {\r\n//                     console.log(`Move blocked due to potential collision.`);\r\n//                 }\r\n//             }\r\n//         }\r\n//     } else {\r\n//         selectedObject = null; // Deselect any selected object\r\n//     }\r\n//   }\r\n// }\r\n\r\n// // function to check collisions\r\n// function checkForCollisions(objectData, newPosition) {\r\n//     let tempBox = new THREE.Box3().copy(objectData.box);  // Copy the existing box\r\n//     tempBox.setFromObject(objectData.model);  // Update to the new position temporarily\r\n//     tempBox.translate(new THREE.Vector3(newPosition.x - objectData.model.position.x, 0, newPosition.z - objectData.model.position.z));\r\n    \r\n//     for (let key in objects) {\r\n//         if (objects[key] !== objectData && tempBox.intersectsBox(objects[key].box)) {\r\n//             console.log(`Collision detected with ${key}`);\r\n//             return true;  // Collision detected\r\n//         }\r\n//     }\r\n//     return false;  // No collision\r\n// }\r\n\r\n\r\n// let controls;\r\n\r\n// export function onDocumentKeyDown(event) {\r\n//     // Implementation of key down interactions\r\n//     if (selectedObject) {\r\n//         switch (event.key) {\r\n//             case \"ArrowRight\":\r\n//                 moveObject(selectedObject, 'right');\r\n//                 break;\r\n//             case \"ArrowLeft\":\r\n//                 moveObject(selectedObject, 'left');\r\n//                 break;\r\n//             case \"ArrowUp\":\r\n//                 moveObject(selectedObject, 'forward');\r\n//                 break;\r\n//             case \"ArrowDown\":\r\n//                 moveObject(selectedObject, 'backward');\r\n//                 break;\r\n//             case \"Escape\":\r\n//                 selectedObject = null;\r\n//                 console.log(\"deselected\");\r\n//                 break;\r\n//             case \"l\":\r\n//                 rotateObject(selectedObject, 4);\r\n//                 break;\r\n//         }\r\n//     }\r\n//   }\r\n\r\n// function moveObject(object, direction) {\r\n//     const distance = 0.25; // Distance to move in each step, adjust as needed\r\n//     switch (direction) {\r\n//         case 'left':\r\n//             object.model.position.x += distance;\r\n//             break;\r\n//         case 'right':\r\n//             object.model.position.x -= distance;\r\n//             break;\r\n//         case 'backward':\r\n//             object.model.position.z -= distance;\r\n//             break;\r\n//         case 'forward':\r\n//             object.model.position.z += distance;\r\n//             break;\r\n//     }\r\n//     object.box.setFromObject(object.model);  // Update the bounding box\r\n//   }\r\n\r\n// function rotateObject(object, angleInDegrees) {\r\n//   const angleInRadians = angleInDegrees * Math.PI / 180;\r\n//   object.model.rotation.y += angleInRadians;  // Rotate around the y-axis\r\n//   object.box.setFromObject(object.model);  // Update the bounding box\r\n// }\r\n\r\nlet cloneCounter = 1;\r\n// Define a function to create new instance of the light\r\nfunction createLightInstance() {\r\n    // Clone the model to create a new instance\r\n    let model;\r\n    if (modelGroups[selectedIndex].name.startsWith('studio_light')) {\r\n        model = modelGroups[selectedIndex];\r\n    } else {\r\n        model = modelGroups.find(group => group.name.startsWith('studio_light'));\r\n    }\r\n\t\r\n    model.rotation.set(0,0,0);\r\n    const newModel = model.clone(true);\r\n    newModel.traverse((node) => {\r\n        if (node.isMesh) {\r\n            node.material = node.material.clone();\r\n        }\r\n    });\r\n\r\n\tnewModel.name = \"studio_light \" + cloneCounter++;\r\n    // Adjust position, scale, or any other properties if needed\r\n    // For example:\r\n    newModel.position.set(1, 0, -5);\r\n    \r\n    // Add the new instance to the scene\r\n    scene.add(newModel);\r\n    \r\n    // Compute the bounding box to get size\r\n    const boundingBox = new THREE.Box3().setFromObject(newModel);\r\n    const size = new THREE.Vector3();\r\n    boundingBox.getSize(size);\r\n\r\n    // Create BoxGeometry based on the computed size\r\n    const modelDragBox = new THREE.Mesh(\r\n        new THREE.BoxGeometry(size.x, size.y, size.z),\r\n        new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 })\r\n    );\r\n    modelDragBox.position.copy(newModel.position);\r\n    modelDragBox.userData.originalY = modelDragBox.position.y += size.y / 2\r\n    scene.add(modelDragBox);\r\n    \r\n    const boxHelper = new THREE.BoxHelper(modelDragBox, 0xffff00);\r\n    boxHelper.visible = false;\r\n    \r\n    scene.add(boxHelper);\r\n    \r\n    modelGroups.push(newModel)\r\n    sceneMeshes.push(modelDragBox);\r\n    modelDragBoxes.push(modelDragBox);\r\n    boxHelpers.push(boxHelper);\r\n}\r\n\r\n// Function to delete the selected light instance\r\nfunction deleteLightInstance(index) {\r\n    if (modelGroups[index].name.startsWith('studio_light')) {\r\n        scene.remove(modelGroups[index]);\r\n        modelGroups.splice(index, 1);\r\n        sceneMeshes.splice(index, 1);\r\n        boxHelpers.splice(index, 1);\r\n        modelDragBoxes.splice(index, 1);\r\n        setSelectedIndex(0);\r\n    }\r\n}\r\n\r\n// Event listener for moving objects\r\n// document.addEventListener('mousedown', onDocumentMouseDown);\r\n// document.addEventListener('keydown', onDocumentKeyDown);\r\n\r\n// // Event listener for opening lighting control slideout\r\n// document.getElementById(\"openButton\").addEventListener(\"click\", openSlideOut);\r\n// document.getElementById(\"closeButton\").addEventListener(\"click\", closeSlideOut);\r\n// // Event listener for opening lighting control slideout\r\n// document.getElementById(\"openButton\").addEventListener(\"click\", openSlideOut);\r\n// document.getElementById(\"closeButton\").addEventListener(\"click\", closeSlideOut);\r\n\r\n// Control the lighting control slideout\r\n// export function openSlideOut() {\r\n//     document.getElementById(\"rightSlideout\").style.right = \"0\";\r\n// }\r\n// export function openSlideOut() {\r\n//     document.getElementById(\"rightSlideout\").style.right = \"0\";\r\n// }\r\n\r\n// export function closeSlideOut() {\r\n//     document.getElementById(\"rightSlideout\").style.right = \"-250px\";\r\n// }\r\n\r\n\r\n\r\n\r\n// Function to apply intensity change - Updated\r\nfunction applyIntensityChange(index) {\r\n    if (modelGroups[index].name.startsWith('studio_light')) {\r\n        const intensityInput = document.getElementById(\"intensityInput\");\r\n        const intensity = parseFloat(intensityInput.value);\r\n        modelGroups[index].traverse((child) => {\r\n            if (child.isMesh) {\r\n                if (child.name == \"Object_7\") {\r\n                    const pointLight = child.children[0];\r\n                    if (!isNaN(intensity)) {\r\n                        pointLight.intensity = intensity;\r\n                    }\r\n                }\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\n// Function to apply color change - Updated\r\nfunction applyColorChange(index) {\r\n    if (modelGroups[index].name.startsWith('studio_light')) {\r\n        const colorPicker = document.getElementById(\"colorPicker\");\r\n        const color = new THREE.Color(colorPicker.value);\r\n        modelGroups[index].traverse((child) => {\r\n            if (child.isMesh) {\r\n                if (child.name == \"Object_7\") {\r\n                    const pointLight = child.children[0];\r\n                    pointLight.color = color;\r\n                    console.log(\"found\");\r\n                    child.material.emissive.set(color);\r\n                }\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\n// Function to populate the studio light dropdown menu\r\nexport function updateStudioLightDropdown() {\r\n    const dropdown = document.getElementById('lightInstanceDropdown');\r\n    dropdown.innerHTML = '<option value=\"\">Select a Light Instance</option>'; // Clear previous options\r\n\r\n    modelGroups.forEach((modelGroup, index) => {\r\n        if (modelGroup.name.startsWith('studio_light')) {\r\n            const optionElement = document.createElement('option');\r\n            optionElement.value = index;\r\n            optionElement.textContent = modelGroup.name;\r\n            dropdown.appendChild(optionElement);\r\n        }\r\n    });\r\n}\r\n"],"names":["modules","entry","mainEntry","parcelRequireName","globalName","globalObject","globalThis","self","window","global","previousRequire","cache","nodeRequire","module","require","bind","newRequire","name","jumped","currentRequire","err","Error","code","localRequire","resolve","x","id","Module","call","exports","res","isParcelRequire","moduleName","bundle","parent","register","Object","defineProperty","get","i","length","mainExports","define","amd","parcelHelpers","defineInteropFlag","export","updateStudioLightDropdown","_three","_scriptsJs","document","getElementById","addEventListener","applyIntensityChange","index","modelGroups","startsWith","intensity","parseFloat","intensityInput","value","traverse","child","isMesh","pointLight","children","isNaN","parseInt","applyColorChange","colorPicker","color","Color","console","log","material","emissive","set","scene","remove","splice","sceneMeshes","boxHelpers","modelDragBoxes","setSelectedIndex","selectedLightIndex","selectedIndex","createLightInstance","model","find","group","rotation","newModel","clone","node","cloneCounter","position","add","boundingBox","Box3","setFromObject","size","Vector3","getSize","modelDragBox","Mesh","BoxGeometry","y","z","MeshBasicMaterial","transparent","opacity","copy","userData","originalY","boxHelper","BoxHelper","visible","push","dropdown","innerHTML","forEach","modelGroup","optionElement","createElement","textContent","appendChild"],"version":3,"file":"index.9bb3d68b.js.map"}
{"mappings":"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","sources":["<anon>","node_modules/webm-writer/WebMWriter.js"],"sourcesContent":["/**\n * WebM video encoder for Google Chrome. This implementation is suitable for creating very large video files, because\n * it can stream Blobs directly to a FileWriter without buffering the entire video in memory.\n *\n * When FileWriter is not available or not desired, it can buffer the video in memory as a series of Blobs which are\n * eventually returned as one composite Blob.\n *\n * By Nicholas Sherlock.\n *\n * Based on the ideas from Whammy: https://github.com/antimatter15/whammy\n *\n * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n */ \"use strict\";\n(function() {\n    function extend(base, top) {\n        let target = {};\n        [\n            base,\n            top\n        ].forEach(function(obj) {\n            for(let prop in obj)if (Object.prototype.hasOwnProperty.call(obj, prop)) target[prop] = obj[prop];\n        });\n        return target;\n    }\n    /**\n     * Decode a Base64 data URL into a binary string.\n     *\n     * @return {String} The binary string\n     */ function decodeBase64WebPDataURL(url) {\n        if (typeof url !== \"string\" || !url.match(/^data:image\\/webp;base64,/i)) throw new Error(\"Failed to decode WebP Base64 URL\");\n        return window.atob(url.substring(23));\n    }\n    /**\n     * Convert the given canvas to a WebP encoded image and return the image data as a string.\n     *\n     * @return {String}\n     */ function renderAsWebP(canvas, quality) {\n        let frame = typeof canvas === \"string\" && /^data:image\\/webp/.test(canvas) ? canvas : canvas.toDataURL(\"image/webp\", quality);\n        return decodeBase64WebPDataURL(frame);\n    }\n    /**\n     * @param {String} string\n     * @returns {number}\n     */ function byteStringToUint32LE(string) {\n        let a = string.charCodeAt(0), b = string.charCodeAt(1), c = string.charCodeAt(2), d = string.charCodeAt(3);\n        return (a | b << 8 | c << 16 | d << 24) >>> 0;\n    }\n    /**\n     * Extract a VP8 keyframe from a WebP image file.\n     *\n     * @param {String} webP - Raw binary string\n     *\n     * @returns {{hasAlpha: boolean, frame: string}}\n     */ function extractKeyframeFromWebP(webP) {\n        let cursor = webP.indexOf(\"VP8\", 12); // Start the search after the 12-byte file header\n        if (cursor === -1) throw new Error(\"Bad image format, does this browser support WebP?\");\n        let hasAlpha = false;\n        /* Cursor now is either directly pointing at a \"VP8 \" keyframe, or a \"VP8X\" extended format file header\n         * Seek through chunks until we find the \"VP8 \" chunk we're interested in\n         */ while(cursor < webP.length - 8){\n            let chunkLength, fourCC;\n            fourCC = webP.substring(cursor, cursor + 4);\n            cursor += 4;\n            chunkLength = byteStringToUint32LE(webP.substring(cursor, cursor + 4));\n            cursor += 4;\n            switch(fourCC){\n                case \"VP8 \":\n                    return {\n                        frame: webP.substring(cursor, cursor + chunkLength),\n                        hasAlpha: hasAlpha\n                    };\n                case \"ALPH\":\n                    hasAlpha = true;\n                    break;\n            }\n            cursor += chunkLength;\n            if ((chunkLength & 0x01) !== 0) cursor++;\n        }\n        throw new Error(\"Failed to find VP8 keyframe in WebP image, is this image mistakenly encoded in the Lossless WebP format?\");\n    }\n    const EBML_SIZE_UNKNOWN = -1, EBML_SIZE_UNKNOWN_5_BYTES = -2;\n    // Just a little utility so we can tag values as floats for the EBML encoder's benefit\n    function EBMLFloat32(value) {\n        this.value = value;\n    }\n    function EBMLFloat64(value) {\n        this.value = value;\n    }\n    /**\n     * Write the given EBML object to the provided ArrayBufferStream.\n     *\n     * @param buffer\n     * @param {Number} bufferFileOffset - The buffer's first byte is at this position inside the video file.\n     *                                    This is used to complete offset and dataOffset fields in each EBML structure,\n     *                                    indicating the file offset of the first byte of the EBML element and\n     *                                    its data payload.\n     * @param {*} ebml\n     */ function writeEBML(buffer, bufferFileOffset, ebml) {\n        // Is the ebml an array of sibling elements?\n        if (Array.isArray(ebml)) for(let i = 0; i < ebml.length; i++)writeEBML(buffer, bufferFileOffset, ebml[i]);\n        else if (typeof ebml === \"string\") buffer.writeString(ebml);\n        else if (ebml instanceof Uint8Array) buffer.writeBytes(ebml);\n        else if (ebml.id) {\n            // We're writing an EBML element\n            ebml.offset = buffer.pos + bufferFileOffset;\n            buffer.writeUnsignedIntBE(ebml.id); // ID field\n            // Now we need to write the size field, so we must know the payload size:\n            if (Array.isArray(ebml.data)) {\n                // Writing an array of child elements. We won't try to measure the size of the children up-front\n                let sizePos, dataBegin, dataEnd;\n                if (ebml.size === EBML_SIZE_UNKNOWN) // Write the reserved all-one-bits marker to note that the size of this element is unknown/unbounded\n                buffer.writeByte(0xFF);\n                else if (ebml.size === EBML_SIZE_UNKNOWN_5_BYTES) {\n                    sizePos = buffer.pos;\n                    // VINT_DATA is all-ones, so this is the reserved \"unknown length\" marker:\n                    buffer.writeBytes([\n                        0x0F,\n                        0xFF,\n                        0xFF,\n                        0xFF,\n                        0xFF\n                    ]);\n                } else {\n                    sizePos = buffer.pos;\n                    /* Write a dummy size field to overwrite later. 4 bytes allows an element maximum size of 256MB,\n\t\t\t\t\t * which should be plenty (we don't want to have to buffer that much data in memory at one time\n\t\t\t\t\t * anyway!)\n\t\t\t\t\t */ buffer.writeBytes([\n                        0,\n                        0,\n                        0,\n                        0\n                    ]);\n                }\n                dataBegin = buffer.pos;\n                ebml.dataOffset = dataBegin + bufferFileOffset;\n                writeEBML(buffer, bufferFileOffset, ebml.data);\n                if (ebml.size !== EBML_SIZE_UNKNOWN && ebml.size !== EBML_SIZE_UNKNOWN_5_BYTES) {\n                    dataEnd = buffer.pos;\n                    ebml.size = dataEnd - dataBegin;\n                    buffer.seek(sizePos);\n                    buffer.writeEBMLVarIntWidth(ebml.size, 4); // Size field\n                    buffer.seek(dataEnd);\n                }\n            } else if (typeof ebml.data === \"string\") {\n                buffer.writeEBMLVarInt(ebml.data.length); // Size field\n                ebml.dataOffset = buffer.pos + bufferFileOffset;\n                buffer.writeString(ebml.data);\n            } else if (typeof ebml.data === \"number\") {\n                // Allow the caller to explicitly choose the size if they wish by supplying a size field\n                if (!ebml.size) ebml.size = buffer.measureUnsignedInt(ebml.data);\n                buffer.writeEBMLVarInt(ebml.size); // Size field\n                ebml.dataOffset = buffer.pos + bufferFileOffset;\n                buffer.writeUnsignedIntBE(ebml.data, ebml.size);\n            } else if (ebml.data instanceof EBMLFloat64) {\n                buffer.writeEBMLVarInt(8); // Size field\n                ebml.dataOffset = buffer.pos + bufferFileOffset;\n                buffer.writeDoubleBE(ebml.data.value);\n            } else if (ebml.data instanceof EBMLFloat32) {\n                buffer.writeEBMLVarInt(4); // Size field\n                ebml.dataOffset = buffer.pos + bufferFileOffset;\n                buffer.writeFloatBE(ebml.data.value);\n            } else if (ebml.data instanceof Uint8Array) {\n                buffer.writeEBMLVarInt(ebml.data.byteLength); // Size field\n                ebml.dataOffset = buffer.pos + bufferFileOffset;\n                buffer.writeBytes(ebml.data);\n            } else throw new Error(\"Bad EBML datatype \" + typeof ebml.data);\n        } else throw new Error(\"Bad EBML datatype \" + typeof ebml.data);\n    }\n    /**\n     * @typedef {Object} Frame\n     * @property {string} frame - Raw VP8 keyframe data\n     * @property {string} alpha - Raw VP8 keyframe with alpha represented as luminance\n     * @property {Number} duration\n     * @property {Number} trackNumber - From 1 to 126 (inclusive)\n     * @property {Number} timecode\n     */ /**\n     * @typedef {Object} Cluster\n     * @property {Number} timecode - Start time for the cluster\n     */ /**\n     * @param ArrayBufferDataStream - Imported library\n     * @param BlobBuffer - Imported library\n     *\n     * @returns WebMWriter\n     *\n     * @constructor\n     */ let WebMWriter = function(ArrayBufferDataStream, BlobBuffer) {\n        return function(options) {\n            let MAX_CLUSTER_DURATION_MSEC = 5000, DEFAULT_TRACK_NUMBER = 1, writtenHeader = false, videoWidth = 0, videoHeight = 0, /**\n                 * @type {[HTMLCanvasElement]}\n                 */ alphaBuffer = null, /**\n                 * @type {[CanvasRenderingContext2D]}\n                 */ alphaBufferContext = null, /**\n                 * @type {[ImageData]}\n                 */ alphaBufferData = null, /**\n                 *\n                 * @type {Frame[]}\n                 */ clusterFrameBuffer = [], clusterStartTime = 0, clusterDuration = 0, optionDefaults = {\n                quality: 0.95,\n                transparent: false,\n                alphaQuality: undefined,\n                // If not specified this defaults to the same value as `quality`.\n                fileWriter: null,\n                fd: null,\n                // You must supply one of:\n                frameDuration: null,\n                frameRate: null\n            }, seekPoints = {\n                Cues: {\n                    id: new Uint8Array([\n                        0x1C,\n                        0x53,\n                        0xBB,\n                        0x6B\n                    ]),\n                    positionEBML: null\n                },\n                SegmentInfo: {\n                    id: new Uint8Array([\n                        0x15,\n                        0x49,\n                        0xA9,\n                        0x66\n                    ]),\n                    positionEBML: null\n                },\n                Tracks: {\n                    id: new Uint8Array([\n                        0x16,\n                        0x54,\n                        0xAE,\n                        0x6B\n                    ]),\n                    positionEBML: null\n                }\n            }, ebmlSegment, segmentDuration = {\n                \"id\": 0x4489,\n                \"data\": new EBMLFloat64(0)\n            }, seekHead, cues = [], blobBuffer = new BlobBuffer(options.fileWriter || options.fd);\n            function fileOffsetToSegmentRelative(fileOffset) {\n                return fileOffset - ebmlSegment.dataOffset;\n            }\n            /**\n             * Extracts the transparency channel from the supplied canvas and uses it to create a VP8 alpha channel bitstream.\n             *\n             * @param {HTMLCanvasElement} source\n             *\n             * @return {HTMLCanvasElement}\n             */ function convertAlphaToGrayscaleImage(source) {\n                if (alphaBuffer === null || alphaBuffer.width !== source.width || alphaBuffer.height !== source.height) {\n                    alphaBuffer = document.createElement(\"canvas\");\n                    alphaBuffer.width = source.width;\n                    alphaBuffer.height = source.height;\n                    alphaBufferContext = alphaBuffer.getContext(\"2d\");\n                    alphaBufferData = alphaBufferContext.createImageData(alphaBuffer.width, alphaBuffer.height);\n                }\n                let sourceContext = source.getContext(\"2d\"), sourceData = sourceContext.getImageData(0, 0, source.width, source.height).data, destData = alphaBufferData.data, dstCursor = 0, srcEnd = source.width * source.height * 4;\n                for(let srcCursor = 3 /* Since pixel byte order is RGBA */ ; srcCursor < srcEnd; srcCursor += 4){\n                    let alpha = sourceData[srcCursor];\n                    // Turn the original alpha channel into a brightness value (ends up being the Y in YUV)\n                    destData[dstCursor++] = alpha;\n                    destData[dstCursor++] = alpha;\n                    destData[dstCursor++] = alpha;\n                    destData[dstCursor++] = 255;\n                }\n                alphaBufferContext.putImageData(alphaBufferData, 0, 0);\n                return alphaBuffer;\n            }\n            /**\n             * Create a SeekHead element with descriptors for the points in the global seekPoints array.\n             *\n             * 5 bytes of position values are reserved for each node, which lie at the offset point.positionEBML.dataOffset,\n             * to be overwritten later.\n             */ function createSeekHead() {\n                let seekPositionEBMLTemplate = {\n                    \"id\": 0x53AC,\n                    \"size\": 5,\n                    \"data\": 0 // We'll overwrite this when the file is complete\n                }, result = {\n                    \"id\": 0x114D9B74,\n                    \"data\": []\n                };\n                for(let name in seekPoints){\n                    let seekPoint = seekPoints[name];\n                    seekPoint.positionEBML = Object.create(seekPositionEBMLTemplate);\n                    result.data.push({\n                        \"id\": 0x4DBB,\n                        \"data\": [\n                            {\n                                \"id\": 0x53AB,\n                                \"data\": seekPoint.id\n                            },\n                            seekPoint.positionEBML\n                        ]\n                    });\n                }\n                return result;\n            }\n            /**\n             * Write the WebM file header to the stream.\n             */ function writeHeader() {\n                seekHead = createSeekHead();\n                let ebmlHeader = {\n                    \"id\": 0x1a45dfa3,\n                    \"data\": [\n                        {\n                            \"id\": 0x4286,\n                            \"data\": 1\n                        },\n                        {\n                            \"id\": 0x42f7,\n                            \"data\": 1\n                        },\n                        {\n                            \"id\": 0x42f2,\n                            \"data\": 4\n                        },\n                        {\n                            \"id\": 0x42f3,\n                            \"data\": 8\n                        },\n                        {\n                            \"id\": 0x4282,\n                            \"data\": \"webm\"\n                        },\n                        {\n                            \"id\": 0x4287,\n                            \"data\": 2\n                        },\n                        {\n                            \"id\": 0x4285,\n                            \"data\": 2\n                        }\n                    ]\n                }, segmentInfo = {\n                    \"id\": 0x1549a966,\n                    \"data\": [\n                        {\n                            \"id\": 0x2ad7b1,\n                            \"data\": 1e6 // Times will be in miliseconds (1e6 nanoseconds per step = 1ms)\n                        },\n                        {\n                            \"id\": 0x4d80,\n                            \"data\": \"webm-writer-js\"\n                        },\n                        {\n                            \"id\": 0x5741,\n                            \"data\": \"webm-writer-js\"\n                        },\n                        segmentDuration // To be filled in later\n                    ]\n                }, videoProperties = [\n                    {\n                        \"id\": 0xb0,\n                        \"data\": videoWidth\n                    },\n                    {\n                        \"id\": 0xba,\n                        \"data\": videoHeight\n                    }\n                ];\n                if (options.transparent) videoProperties.push({\n                    \"id\": 0x53C0,\n                    \"data\": 1\n                });\n                let tracks = {\n                    \"id\": 0x1654ae6b,\n                    \"data\": [\n                        {\n                            \"id\": 0xae,\n                            \"data\": [\n                                {\n                                    \"id\": 0xd7,\n                                    \"data\": DEFAULT_TRACK_NUMBER\n                                },\n                                {\n                                    \"id\": 0x73c5,\n                                    \"data\": DEFAULT_TRACK_NUMBER\n                                },\n                                {\n                                    \"id\": 0x9c,\n                                    \"data\": 0\n                                },\n                                {\n                                    \"id\": 0x22b59c,\n                                    \"data\": \"und\"\n                                },\n                                {\n                                    \"id\": 0x86,\n                                    \"data\": \"V_VP8\"\n                                },\n                                {\n                                    \"id\": 0x258688,\n                                    \"data\": \"VP8\"\n                                },\n                                {\n                                    \"id\": 0x83,\n                                    \"data\": 1\n                                },\n                                {\n                                    \"id\": 0xe0,\n                                    \"data\": videoProperties\n                                }\n                            ]\n                        }\n                    ]\n                };\n                ebmlSegment = {\n                    \"id\": 0x18538067,\n                    \"size\": EBML_SIZE_UNKNOWN_5_BYTES,\n                    \"data\": [\n                        seekHead,\n                        segmentInfo,\n                        tracks\n                    ]\n                };\n                let bufferStream = new ArrayBufferDataStream(256);\n                writeEBML(bufferStream, blobBuffer.pos, [\n                    ebmlHeader,\n                    ebmlSegment\n                ]);\n                blobBuffer.write(bufferStream.getAsDataArray());\n                // Now we know where these top-level elements lie in the file:\n                seekPoints.SegmentInfo.positionEBML.data = fileOffsetToSegmentRelative(segmentInfo.offset);\n                seekPoints.Tracks.positionEBML.data = fileOffsetToSegmentRelative(tracks.offset);\n                writtenHeader = true;\n            }\n            /**\n             * Create a BlockGroup element to hold the given keyframe (used when alpha support is required)\n             *\n             * @param {Frame} keyframe\n             *\n             * @return A BlockGroup EBML element\n             */ function createBlockGroupForTransparentKeyframe(keyframe) {\n                let block, blockAdditions, bufferStream = new ArrayBufferDataStream(4);\n                // Create a Block to hold the image data:\n                if (!(keyframe.trackNumber > 0 && keyframe.trackNumber < 127)) throw new Error(\"TrackNumber must be > 0 and < 127\");\n                bufferStream.writeEBMLVarInt(keyframe.trackNumber); // Always 1 byte since we limit the range of trackNumber\n                bufferStream.writeU16BE(keyframe.timecode);\n                bufferStream.writeByte(0); // Flags byte\n                block = {\n                    \"id\": 0xA1,\n                    \"data\": [\n                        bufferStream.getAsDataArray(),\n                        keyframe.frame\n                    ]\n                };\n                blockAdditions = {\n                    \"id\": 0x75A1,\n                    \"data\": [\n                        {\n                            \"id\": 0xA6,\n                            \"data\": [\n                                {\n                                    \"id\": 0xEE,\n                                    \"data\": 1 // Means \"BlockAdditional has a codec-defined meaning, pass it to the codec\"\n                                },\n                                {\n                                    \"id\": 0xA5,\n                                    \"data\": keyframe.alpha // The actual alpha channel image\n                                }\n                            ]\n                        }\n                    ]\n                };\n                return {\n                    \"id\": 0xA0,\n                    \"data\": [\n                        block,\n                        blockAdditions\n                    ]\n                };\n            }\n            /**\n             * Create a SimpleBlock element to hold the given keyframe.\n             *\n             * @param {Frame} keyframe\n             *\n             * @return A SimpleBlock EBML element.\n             */ function createSimpleBlockForKeyframe(keyframe) {\n                let bufferStream = new ArrayBufferDataStream(4);\n                if (!(keyframe.trackNumber > 0 && keyframe.trackNumber < 127)) throw new Error(\"TrackNumber must be > 0 and < 127\");\n                bufferStream.writeEBMLVarInt(keyframe.trackNumber); // Always 1 byte since we limit the range of trackNumber\n                bufferStream.writeU16BE(keyframe.timecode);\n                // Flags byte\n                bufferStream.writeByte(128 // Keyframe\n                );\n                return {\n                    \"id\": 0xA3,\n                    \"data\": [\n                        bufferStream.getAsDataArray(),\n                        keyframe.frame\n                    ]\n                };\n            }\n            /**\n             * Create either a SimpleBlock or BlockGroup (if alpha is required) for the given keyframe.\n             *\n             * @param {Frame} keyframe\n             */ function createContainerForKeyframe(keyframe) {\n                if (keyframe.alpha) return createBlockGroupForTransparentKeyframe(keyframe);\n                return createSimpleBlockForKeyframe(keyframe);\n            }\n            /**\n             * Create a Cluster EBML node.\n             *\n             * @param {Cluster} cluster\n             *\n             * Returns an EBML element.\n             */ function createCluster(cluster) {\n                return {\n                    \"id\": 0x1f43b675,\n                    \"data\": [\n                        {\n                            \"id\": 0xe7,\n                            \"data\": Math.round(cluster.timecode)\n                        }\n                    ]\n                };\n            }\n            function addCuePoint(trackIndex, clusterTime, clusterFileOffset) {\n                cues.push({\n                    \"id\": 0xBB,\n                    \"data\": [\n                        {\n                            \"id\": 0xB3,\n                            \"data\": clusterTime\n                        },\n                        {\n                            \"id\": 0xB7,\n                            \"data\": [\n                                {\n                                    \"id\": 0xF7,\n                                    \"data\": trackIndex\n                                },\n                                {\n                                    \"id\": 0xF1,\n                                    \"data\": fileOffsetToSegmentRelative(clusterFileOffset)\n                                }\n                            ]\n                        }\n                    ]\n                });\n            }\n            /**\n             * Write a Cues element to the blobStream using the global `cues` array of CuePoints (use addCuePoint()).\n             * The seek entry for the Cues in the SeekHead is updated.\n             */ function writeCues() {\n                let ebml = {\n                    \"id\": 0x1C53BB6B,\n                    \"data\": cues\n                }, cuesBuffer = new ArrayBufferDataStream(16 + cues.length * 32); // Pretty crude estimate of the buffer size we'll need\n                writeEBML(cuesBuffer, blobBuffer.pos, ebml);\n                blobBuffer.write(cuesBuffer.getAsDataArray());\n                // Now we know where the Cues element has ended up, we can update the SeekHead\n                seekPoints.Cues.positionEBML.data = fileOffsetToSegmentRelative(ebml.offset);\n            }\n            /**\n             * Flush the frames in the current clusterFrameBuffer out to the stream as a Cluster.\n             */ function flushClusterFrameBuffer() {\n                if (clusterFrameBuffer.length === 0) return;\n                // First work out how large of a buffer we need to hold the cluster data\n                let rawImageSize = 0;\n                for(let i = 0; i < clusterFrameBuffer.length; i++)rawImageSize += clusterFrameBuffer[i].frame.length + (clusterFrameBuffer[i].alpha ? clusterFrameBuffer[i].alpha.length : 0);\n                let buffer = new ArrayBufferDataStream(rawImageSize + clusterFrameBuffer.length * 64), cluster = createCluster({\n                    timecode: Math.round(clusterStartTime)\n                });\n                for(let i = 0; i < clusterFrameBuffer.length; i++)cluster.data.push(createContainerForKeyframe(clusterFrameBuffer[i]));\n                writeEBML(buffer, blobBuffer.pos, cluster);\n                blobBuffer.write(buffer.getAsDataArray());\n                addCuePoint(DEFAULT_TRACK_NUMBER, Math.round(clusterStartTime), cluster.offset);\n                clusterFrameBuffer = [];\n                clusterStartTime += clusterDuration;\n                clusterDuration = 0;\n            }\n            function validateOptions() {\n                // Derive frameDuration setting if not already supplied\n                if (!options.frameDuration) {\n                    if (options.frameRate) options.frameDuration = 1000 / options.frameRate;\n                    else throw new Error(\"Missing required frameDuration or frameRate setting\");\n                }\n                // Avoid 1.0 (lossless) because it creates VP8L lossless frames that WebM doesn't support\n                options.quality = Math.max(Math.min(options.quality, 0.99999), 0);\n                if (options.alphaQuality === undefined) options.alphaQuality = options.quality;\n                else options.alphaQuality = Math.max(Math.min(options.alphaQuality, 0.99999), 0);\n            }\n            /**\n             *\n             * @param {Frame} frame\n             */ function addFrameToCluster(frame) {\n                frame.trackNumber = DEFAULT_TRACK_NUMBER;\n                // Frame timecodes are relative to the start of their cluster:\n                frame.timecode = Math.round(clusterDuration);\n                clusterFrameBuffer.push(frame);\n                clusterDuration += frame.duration;\n                if (clusterDuration >= MAX_CLUSTER_DURATION_MSEC) flushClusterFrameBuffer();\n            }\n            /**\n             * Rewrites the SeekHead element that was initially written to the stream with the offsets of top level elements.\n             *\n             * Call once writing is complete (so the offset of all top level elements is known).\n             */ function rewriteSeekHead() {\n                let seekHeadBuffer = new ArrayBufferDataStream(seekHead.size), oldPos = blobBuffer.pos;\n                // Write the rewritten SeekHead element's data payload to the stream (don't need to update the id or size)\n                writeEBML(seekHeadBuffer, seekHead.dataOffset, seekHead.data);\n                // And write that through to the file\n                blobBuffer.seek(seekHead.dataOffset);\n                blobBuffer.write(seekHeadBuffer.getAsDataArray());\n                blobBuffer.seek(oldPos);\n            }\n            /**\n             * Rewrite the Duration field of the Segment with the newly-discovered video duration.\n             */ function rewriteDuration() {\n                let buffer = new ArrayBufferDataStream(8), oldPos = blobBuffer.pos;\n                // Rewrite the data payload (don't need to update the id or size)\n                buffer.writeDoubleBE(clusterStartTime);\n                // And write that through to the file\n                blobBuffer.seek(segmentDuration.dataOffset);\n                blobBuffer.write(buffer.getAsDataArray());\n                blobBuffer.seek(oldPos);\n            }\n            /**\n             * Rewrite the size field of the Segment.\n             */ function rewriteSegmentLength() {\n                let buffer = new ArrayBufferDataStream(10), oldPos = blobBuffer.pos;\n                // We just need to rewrite the ID and Size fields of the root Segment:\n                buffer.writeUnsignedIntBE(ebmlSegment.id);\n                buffer.writeEBMLVarIntWidth(blobBuffer.pos - ebmlSegment.dataOffset, 5);\n                // And write that on top of the original:\n                blobBuffer.seek(ebmlSegment.offset);\n                blobBuffer.write(buffer.getAsDataArray());\n                blobBuffer.seek(oldPos);\n            }\n            /**\n             * Add a frame to the video.\n             *\n             * @param {HTMLCanvasElement|String} frame - A Canvas element that contains the frame, or a WebP string\n             *                                           you obtained by calling toDataUrl() on an image yourself.\n             *\n             * @param {HTMLCanvasElement|String} [alpha] - For transparent video, instead of including the alpha channel\n             *                                             in your provided `frame`, you can instead provide it separately\n             *                                             here. The alpha channel of this alpha canvas will be ignored,\n             *                                             encode your alpha information into this canvas' grayscale\n             *                                             brightness instead.\n             *\n             *                                             This is useful because it allows you to paint the colours\n             *                                             you need into your `frame` even in regions which are fully\n             *                                             transparent (which Canvas doesn't normally let you influence).\n             *                                             This allows you to control the colour of the fringing seen\n             *                                             around objects on transparent backgrounds.\n             *\n             * @param {Number} [overrideFrameDuration] - Set a duration for this frame (in milliseconds) that differs\n             *                                           from the default\n             */ this.addFrame = function(frame, alpha, overrideFrameDuration) {\n                if (!writtenHeader) {\n                    videoWidth = frame.width || 0;\n                    videoHeight = frame.height || 0;\n                    writeHeader();\n                }\n                let keyframe = extractKeyframeFromWebP(renderAsWebP(frame, options.quality)), frameDuration, frameAlpha = null;\n                if (overrideFrameDuration) frameDuration = overrideFrameDuration;\n                else if (typeof alpha == \"number\") frameDuration = alpha;\n                else frameDuration = options.frameDuration;\n                if (options.transparent) {\n                    if (alpha instanceof HTMLCanvasElement || typeof alpha === \"string\") frameAlpha = alpha;\n                    else if (keyframe.hasAlpha) frameAlpha = convertAlphaToGrayscaleImage(frame);\n                }\n                addFrameToCluster({\n                    frame: keyframe.frame,\n                    duration: frameDuration,\n                    alpha: frameAlpha ? extractKeyframeFromWebP(renderAsWebP(frameAlpha, options.alphaQuality)).frame : null\n                });\n            };\n            /**\n             * Finish writing the video and return a Promise to signal completion.\n             *\n             * If the destination device was memory (i.e. options.fileWriter was not supplied), the Promise is resolved with\n             * a Blob with the contents of the entire video.\n             */ this.complete = function() {\n                if (!writtenHeader) writeHeader();\n                flushClusterFrameBuffer();\n                writeCues();\n                /* \n                 * Now the file is at its final length and the position of all elements is known, seek back to the\n                 * header and update pointers:\n                 */ rewriteSeekHead();\n                rewriteDuration();\n                rewriteSegmentLength();\n                return blobBuffer.complete(\"video/webm\");\n            };\n            this.getWrittenSize = function() {\n                return blobBuffer.length;\n            };\n            options = extend(optionDefaults, options || {});\n            validateOptions();\n        };\n    };\n    if (typeof module !== \"undefined\" && typeof module.exports !== \"undefined\") module.exports = WebMWriter;\n    else window.WebMWriter = WebMWriter(window.ArrayBufferDataStream, window.BlobBuffer);\n})();\n\n//# sourceMappingURL=index.dbcadfc6.js.map\n","/**\n * WebM video encoder for Google Chrome. This implementation is suitable for creating very large video files, because\n * it can stream Blobs directly to a FileWriter without buffering the entire video in memory.\n *\n * When FileWriter is not available or not desired, it can buffer the video in memory as a series of Blobs which are\n * eventually returned as one composite Blob.\n *\n * By Nicholas Sherlock.\n *\n * Based on the ideas from Whammy: https://github.com/antimatter15/whammy\n *\n * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n */\n\n\"use strict\";\n\n(function() {\n    function extend(base, top) {\n        let\n            target = {};\n        \n        [base, top].forEach(function(obj) {\n            for (let prop in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n                    target[prop] = obj[prop];\n                }\n            }\n        });\n        \n        return target;\n    }\n    \n    /**\n     * Decode a Base64 data URL into a binary string.\n     *\n     * @return {String} The binary string\n     */\n    function decodeBase64WebPDataURL(url) {\n        if (typeof url !== \"string\" || !url.match(/^data:image\\/webp;base64,/i)) {\n            throw new Error(\"Failed to decode WebP Base64 URL\");\n        }\n        \n        return window.atob(url.substring(\"data:image\\/webp;base64,\".length));\n    }\n    \n    /**\n     * Convert the given canvas to a WebP encoded image and return the image data as a string.\n     *\n     * @return {String}\n     */\n    function renderAsWebP(canvas, quality) {\n        let\n            frame = typeof canvas === 'string' && /^data:image\\/webp/.test(canvas)\n                ? canvas\n                : canvas.toDataURL('image/webp', quality);\n        \n        return decodeBase64WebPDataURL(frame);\n    }\n    \n    /**\n     * @param {String} string\n     * @returns {number}\n     */\n    function byteStringToUint32LE(string) {\n        let\n            a = string.charCodeAt(0),\n            b = string.charCodeAt(1),\n            c = string.charCodeAt(2),\n            d = string.charCodeAt(3);\n    \n        return (a | (b << 8) | (c << 16) | (d << 24)) >>> 0;\n    }\n    \n    /**\n     * Extract a VP8 keyframe from a WebP image file.\n     *\n     * @param {String} webP - Raw binary string\n     *\n     * @returns {{hasAlpha: boolean, frame: string}}\n     */\n    function extractKeyframeFromWebP(webP) {\n        let\n            cursor = webP.indexOf('VP8', 12); // Start the search after the 12-byte file header\n    \n        if (cursor === -1) {\n            throw new Error(\"Bad image format, does this browser support WebP?\");\n        }\n        \n        let\n            hasAlpha = false;\n    \n        /* Cursor now is either directly pointing at a \"VP8 \" keyframe, or a \"VP8X\" extended format file header\n         * Seek through chunks until we find the \"VP8 \" chunk we're interested in\n         */\n        while (cursor < webP.length - 8) {\n            let\n                chunkLength, fourCC;\n    \n            fourCC = webP.substring(cursor, cursor + 4);\n            cursor += 4;\n\n            chunkLength = byteStringToUint32LE(webP.substring(cursor, cursor + 4));\n            cursor += 4;\n            \n            switch (fourCC) {\n                case \"VP8 \":\n                    return {\n                        frame: webP.substring(cursor, cursor + chunkLength),\n                        hasAlpha: hasAlpha\n                    };\n                    \n                case \"ALPH\":\n                    hasAlpha = true;\n                    /* But we otherwise ignore the content of the alpha chunk, since we don't have a decoder for it\n                     * and it isn't VP8-compatible\n                     */\n                    break;\n            }\n            \n            cursor += chunkLength;\n            \n            if ((chunkLength & 0x01) !== 0) {\n                cursor++;\n                // Odd-length chunks have 1 byte of trailing padding that isn't included in their length\n            }\n        }\n        \n        throw new Error(\"Failed to find VP8 keyframe in WebP image, is this image mistakenly encoded in the Lossless WebP format?\");\n    }\n    \n    const \n        EBML_SIZE_UNKNOWN = -1,\n        EBML_SIZE_UNKNOWN_5_BYTES = -2;\n    \n    // Just a little utility so we can tag values as floats for the EBML encoder's benefit\n    function EBMLFloat32(value) {\n        this.value = value;\n    }\n    \n    function EBMLFloat64(value) {\n        this.value = value;\n    }\n    \n    /**\n     * Write the given EBML object to the provided ArrayBufferStream.\n     *\n     * @param buffer\n     * @param {Number} bufferFileOffset - The buffer's first byte is at this position inside the video file.\n     *                                    This is used to complete offset and dataOffset fields in each EBML structure,\n     *                                    indicating the file offset of the first byte of the EBML element and\n     *                                    its data payload.\n     * @param {*} ebml\n     */\n    function writeEBML(buffer, bufferFileOffset, ebml) {\n        // Is the ebml an array of sibling elements?\n        if (Array.isArray(ebml)) {\n            for (let i = 0; i < ebml.length; i++) {\n                writeEBML(buffer, bufferFileOffset, ebml[i]);\n            }\n            // Is this some sort of raw data that we want to write directly?\n        } else if (typeof ebml === \"string\") {\n            buffer.writeString(ebml);\n        } else if (ebml instanceof Uint8Array) {\n            buffer.writeBytes(ebml);\n        } else if (ebml.id){\n            // We're writing an EBML element\n            ebml.offset = buffer.pos + bufferFileOffset;\n            \n            buffer.writeUnsignedIntBE(ebml.id); // ID field\n            \n            // Now we need to write the size field, so we must know the payload size:\n            \n            if (Array.isArray(ebml.data)) {\n                // Writing an array of child elements. We won't try to measure the size of the children up-front\n                \n                let\n                    sizePos, dataBegin, dataEnd;\n                \n                if (ebml.size === EBML_SIZE_UNKNOWN) {\n                    // Write the reserved all-one-bits marker to note that the size of this element is unknown/unbounded\n                    buffer.writeByte(0xFF);\n                } else if (ebml.size === EBML_SIZE_UNKNOWN_5_BYTES) {\n                    sizePos = buffer.pos;\n                    \n                    // VINT_DATA is all-ones, so this is the reserved \"unknown length\" marker:\n                    buffer.writeBytes([0x0F, 0xFF, 0xFF, 0xFF, 0xFF]);\n                } else {\n                    sizePos = buffer.pos;\n                    \n                    /* Write a dummy size field to overwrite later. 4 bytes allows an element maximum size of 256MB,\n\t\t\t\t\t * which should be plenty (we don't want to have to buffer that much data in memory at one time\n\t\t\t\t\t * anyway!)\n\t\t\t\t\t */\n                    buffer.writeBytes([0, 0, 0, 0]);\n                }\n                \n                dataBegin = buffer.pos;\n                \n                ebml.dataOffset = dataBegin + bufferFileOffset;\n                writeEBML(buffer, bufferFileOffset, ebml.data);\n                \n                if (ebml.size !== EBML_SIZE_UNKNOWN && ebml.size !== EBML_SIZE_UNKNOWN_5_BYTES) {\n                    dataEnd = buffer.pos;\n                    \n                    ebml.size = dataEnd - dataBegin;\n                    \n                    buffer.seek(sizePos);\n                    buffer.writeEBMLVarIntWidth(ebml.size, 4); // Size field\n                    \n                    buffer.seek(dataEnd);\n                }\n            } else if (typeof ebml.data === \"string\") {\n                buffer.writeEBMLVarInt(ebml.data.length); // Size field\n                ebml.dataOffset = buffer.pos + bufferFileOffset;\n                buffer.writeString(ebml.data);\n            } else if (typeof ebml.data === \"number\") {\n                // Allow the caller to explicitly choose the size if they wish by supplying a size field\n                if (!ebml.size) {\n                    ebml.size = buffer.measureUnsignedInt(ebml.data);\n                }\n                \n                buffer.writeEBMLVarInt(ebml.size); // Size field\n                ebml.dataOffset = buffer.pos + bufferFileOffset;\n                buffer.writeUnsignedIntBE(ebml.data, ebml.size);\n            } else if (ebml.data instanceof EBMLFloat64) {\n                buffer.writeEBMLVarInt(8); // Size field\n                ebml.dataOffset = buffer.pos + bufferFileOffset;\n                buffer.writeDoubleBE(ebml.data.value);\n            } else if (ebml.data instanceof EBMLFloat32) {\n                buffer.writeEBMLVarInt(4); // Size field\n                ebml.dataOffset = buffer.pos + bufferFileOffset;\n                buffer.writeFloatBE(ebml.data.value);\n            } else if (ebml.data instanceof Uint8Array) {\n                buffer.writeEBMLVarInt(ebml.data.byteLength); // Size field\n                ebml.dataOffset = buffer.pos + bufferFileOffset;\n                buffer.writeBytes(ebml.data);\n            } else {\n                throw new Error(\"Bad EBML datatype \" + typeof ebml.data);\n            }\n        } else {\n            throw new Error(\"Bad EBML datatype \" + typeof ebml.data);\n        }\n    }\n    \n    /**\n     * @typedef {Object} Frame\n     * @property {string} frame - Raw VP8 keyframe data\n     * @property {string} alpha - Raw VP8 keyframe with alpha represented as luminance\n     * @property {Number} duration\n     * @property {Number} trackNumber - From 1 to 126 (inclusive)\n     * @property {Number} timecode\n     */\n    \n    /**\n     * @typedef {Object} Cluster\n     * @property {Number} timecode - Start time for the cluster\n     */\n    \n    /**\n     * @param ArrayBufferDataStream - Imported library\n     * @param BlobBuffer - Imported library\n     *\n     * @returns WebMWriter\n     *\n     * @constructor\n     */\n    let WebMWriter = function(ArrayBufferDataStream, BlobBuffer) {\n        return function(options) {\n            let\n                MAX_CLUSTER_DURATION_MSEC = 5000,\n                DEFAULT_TRACK_NUMBER = 1,\n            \n                writtenHeader = false,\n                videoWidth = 0, videoHeight = 0,\n    \n                /**\n                 * @type {[HTMLCanvasElement]}\n                 */\n                alphaBuffer = null,\n\n                /**\n                 * @type {[CanvasRenderingContext2D]}\n                 */\n                alphaBufferContext = null,\n\n                /**\n                 * @type {[ImageData]}\n                 */\n                alphaBufferData = null,\n    \n                /**\n                 *\n                 * @type {Frame[]}\n                 */\n                clusterFrameBuffer = [],\n                clusterStartTime = 0,\n                clusterDuration = 0,\n                \n                optionDefaults = {\n                    quality: 0.95,       // WebM image quality from 0.0 (worst) to 0.99999 (best), 1.00 (WebP lossless) is not supported\n                    \n                    transparent: false,      // True if an alpha channel should be included in the video\n                    alphaQuality: undefined, // Allows you to set the quality level of the alpha channel separately.\n                                             // If not specified this defaults to the same value as `quality`.\n                    \n                    fileWriter: null,    // Chrome FileWriter in order to stream to a file instead of buffering to memory (optional)\n                    fd: null,            // Node.JS file descriptor to write to instead of buffering (optional)\n                    \n                    // You must supply one of:\n                    frameDuration: null, // Duration of frames in milliseconds\n                    frameRate: null,     // Number of frames per second\n                },\n                \n                seekPoints = {\n                    Cues: {id: new Uint8Array([0x1C, 0x53, 0xBB, 0x6B]), positionEBML: null},\n                    SegmentInfo: {id: new Uint8Array([0x15, 0x49, 0xA9, 0x66]), positionEBML: null},\n                    Tracks: {id: new Uint8Array([0x16, 0x54, 0xAE, 0x6B]), positionEBML: null},\n                },\n                \n                ebmlSegment, // Root element of the EBML document\n                \n                segmentDuration = {\n                    \"id\": 0x4489, // Duration\n                    \"data\": new EBMLFloat64(0)\n                },\n                \n                seekHead,\n                \n                cues = [],\n                \n                blobBuffer = new BlobBuffer(options.fileWriter || options.fd);\n    \n            function fileOffsetToSegmentRelative(fileOffset) {\n                return fileOffset - ebmlSegment.dataOffset;\n            }\n    \n            /**\n             * Extracts the transparency channel from the supplied canvas and uses it to create a VP8 alpha channel bitstream.\n             *\n             * @param {HTMLCanvasElement} source\n             *\n             * @return {HTMLCanvasElement}\n             */\n            function convertAlphaToGrayscaleImage(source) {\n                if (alphaBuffer === null || alphaBuffer.width !== source.width || alphaBuffer.height !== source.height) {\n                    alphaBuffer = document.createElement(\"canvas\");\n                    alphaBuffer.width = source.width;\n                    alphaBuffer.height = source.height;\n                    \n                    alphaBufferContext = alphaBuffer.getContext(\"2d\");\n                    alphaBufferData = alphaBufferContext.createImageData(alphaBuffer.width, alphaBuffer.height);\n                }\n                \n                let\n                    sourceContext = source.getContext(\"2d\"),\n                    sourceData = sourceContext.getImageData(0, 0, source.width, source.height).data,\n                    destData = alphaBufferData.data,\n                    dstCursor = 0,\n                    srcEnd = source.width * source.height * 4;\n                \n                for (let srcCursor = 3 /* Since pixel byte order is RGBA */; srcCursor < srcEnd; srcCursor += 4) {\n                    let\n                        alpha = sourceData[srcCursor];\n                    \n                    // Turn the original alpha channel into a brightness value (ends up being the Y in YUV)\n                    destData[dstCursor++] = alpha;\n                    destData[dstCursor++] = alpha;\n                    destData[dstCursor++] = alpha;\n                    destData[dstCursor++] = 255;\n                }\n                \n                alphaBufferContext.putImageData(alphaBufferData, 0, 0);\n                \n                return alphaBuffer;\n            }\n            \n            /**\n             * Create a SeekHead element with descriptors for the points in the global seekPoints array.\n             *\n             * 5 bytes of position values are reserved for each node, which lie at the offset point.positionEBML.dataOffset,\n             * to be overwritten later.\n             */\n            function createSeekHead() {\n                let\n                    seekPositionEBMLTemplate = {\n                        \"id\": 0x53AC, // SeekPosition\n                        \"size\": 5, // Allows for 32GB video files\n                        \"data\": 0 // We'll overwrite this when the file is complete\n                    },\n                    \n                    result = {\n                        \"id\": 0x114D9B74, // SeekHead\n                        \"data\": []\n                    };\n                \n                for (let name in seekPoints) {\n                    let\n                        seekPoint = seekPoints[name];\n                \n                    seekPoint.positionEBML = Object.create(seekPositionEBMLTemplate);\n                    \n                    result.data.push({\n                         \"id\": 0x4DBB, // Seek\n                         \"data\": [\n                              {\n                                  \"id\": 0x53AB, // SeekID\n                                  \"data\": seekPoint.id\n                              },\n                              seekPoint.positionEBML\n                         ]\n                    });\n                }\n                \n                return result;\n            }\n            \n            /**\n             * Write the WebM file header to the stream.\n             */\n            function writeHeader() {\n                seekHead = createSeekHead();\n                \n                let\n                    ebmlHeader = {\n                        \"id\": 0x1a45dfa3, // EBML\n                        \"data\": [\n                            {\n                                \"id\": 0x4286, // EBMLVersion\n                                \"data\": 1\n                            },\n                            {\n                                \"id\": 0x42f7, // EBMLReadVersion\n                                \"data\": 1\n                            },\n                            {\n                                \"id\": 0x42f2, // EBMLMaxIDLength\n                                \"data\": 4\n                            },\n                            {\n                                \"id\": 0x42f3, // EBMLMaxSizeLength\n                                \"data\": 8\n                            },\n                            {\n                                \"id\": 0x4282, // DocType\n                                \"data\": \"webm\"\n                            },\n                            {\n                                \"id\": 0x4287, // DocTypeVersion\n                                \"data\": 2\n                            },\n                            {\n                                \"id\": 0x4285, // DocTypeReadVersion\n                                \"data\": 2\n                            }\n                        ]\n                    },\n                    \n                    segmentInfo = {\n                        \"id\": 0x1549a966, // Info\n                        \"data\": [\n                            {\n                                \"id\": 0x2ad7b1, // TimecodeScale\n                                \"data\": 1e6 // Times will be in miliseconds (1e6 nanoseconds per step = 1ms)\n                            },\n                            {\n                                \"id\": 0x4d80, // MuxingApp\n                                \"data\": \"webm-writer-js\",\n                            },\n                            {\n                                \"id\": 0x5741, // WritingApp\n                                \"data\": \"webm-writer-js\"\n                            },\n                            segmentDuration // To be filled in later\n                        ]\n                    },\n                    \n                    videoProperties = [\n                        {\n                            \"id\": 0xb0, // PixelWidth\n                            \"data\": videoWidth\n                        },\n                        {\n                            \"id\": 0xba, // PixelHeight\n                            \"data\": videoHeight\n                        }\n                    ];\n                \n                if (options.transparent) {\n                    videoProperties.push(\n                        {\n                            \"id\": 0x53C0, // AlphaMode\n                            \"data\": 1\n                        }\n                    );\n                }\n                \n                let\n                    tracks = {\n                        \"id\": 0x1654ae6b, // Tracks\n                        \"data\": [\n                            {\n                                \"id\": 0xae, // TrackEntry\n                                \"data\": [\n                                    {\n                                        \"id\": 0xd7, // TrackNumber\n                                        \"data\": DEFAULT_TRACK_NUMBER\n                                    },\n                                    {\n                                        \"id\": 0x73c5, // TrackUID\n                                        \"data\": DEFAULT_TRACK_NUMBER\n                                    },\n                                    {\n                                        \"id\": 0x9c, // FlagLacing\n                                        \"data\": 0\n                                    },\n                                    {\n                                        \"id\": 0x22b59c, // Language\n                                        \"data\": \"und\"\n                                    },\n                                    {\n                                        \"id\": 0x86, // CodecID\n                                        \"data\": \"V_VP8\"\n                                    },\n                                    {\n                                        \"id\": 0x258688, // CodecName\n                                        \"data\": \"VP8\"\n                                    },\n                                    {\n                                        \"id\": 0x83, // TrackType\n                                        \"data\": 1\n                                    },\n                                    {\n                                        \"id\": 0xe0,  // Video\n                                        \"data\": videoProperties\n                                    }\n                                ]\n                            }\n                        ]\n                    };\n                \n                ebmlSegment = {\n                    \"id\": 0x18538067, // Segment\n                    \"size\": EBML_SIZE_UNKNOWN_5_BYTES, // We'll seek back and fill this in at completion\n                    \"data\": [\n                        seekHead,\n                        segmentInfo,\n                        tracks,\n                    ]\n                };\n                \n                let\n                    bufferStream = new ArrayBufferDataStream(256);\n                    \n                writeEBML(bufferStream, blobBuffer.pos, [ebmlHeader, ebmlSegment]);\n                blobBuffer.write(bufferStream.getAsDataArray());\n                \n                // Now we know where these top-level elements lie in the file:\n                seekPoints.SegmentInfo.positionEBML.data = fileOffsetToSegmentRelative(segmentInfo.offset);\n                seekPoints.Tracks.positionEBML.data = fileOffsetToSegmentRelative(tracks.offset);\n                \n\t            writtenHeader = true;\n            }\n    \n            /**\n             * Create a BlockGroup element to hold the given keyframe (used when alpha support is required)\n             *\n             * @param {Frame} keyframe\n             *\n             * @return A BlockGroup EBML element\n             */\n            function createBlockGroupForTransparentKeyframe(keyframe) {\n                let\n                    block, blockAdditions,\n                    \n                    bufferStream = new ArrayBufferDataStream(1 + 2 + 1);\n    \n                // Create a Block to hold the image data:\n                \n                if (!(keyframe.trackNumber > 0 && keyframe.trackNumber < 127)) {\n                    throw new Error(\"TrackNumber must be > 0 and < 127\");\n                }\n        \n                bufferStream.writeEBMLVarInt(keyframe.trackNumber); // Always 1 byte since we limit the range of trackNumber\n                bufferStream.writeU16BE(keyframe.timecode);\n                bufferStream.writeByte(0); // Flags byte\n    \n                block = {\n                    \"id\": 0xA1, // Block\n                    \"data\": [\n                        bufferStream.getAsDataArray(),\n                        keyframe.frame\n                    ]\n                };\n    \n                blockAdditions = {\n                    \"id\": 0x75A1, // BlockAdditions\n                    \"data\": [\n                        {\n                            \"id\": 0xA6, // BlockMore\n                            \"data\": [\n                                {\n                                    \"id\": 0xEE, // BlockAddID\n                                    \"data\": 1   // Means \"BlockAdditional has a codec-defined meaning, pass it to the codec\"\n                                },\n                                {\n                                    \"id\": 0xA5, // BlockAdditional\n                                    \"data\": keyframe.alpha // The actual alpha channel image\n                                }\n                            ]\n                        }\n                    ]\n                };\n    \n                return {\n                    \"id\": 0xA0, // BlockGroup\n                    \"data\": [\n                        block,\n                        blockAdditions\n                    ]\n                };\n            }\n            \n            /**\n             * Create a SimpleBlock element to hold the given keyframe.\n             *\n             * @param {Frame} keyframe\n             *\n             * @return A SimpleBlock EBML element.\n             */\n            function createSimpleBlockForKeyframe(keyframe) {\n                let\n                    bufferStream = new ArrayBufferDataStream(1 + 2 + 1);\n                \n                if (!(keyframe.trackNumber > 0 && keyframe.trackNumber < 127)) {\n                    throw new Error(\"TrackNumber must be > 0 and < 127\");\n                }\n    \n                bufferStream.writeEBMLVarInt(keyframe.trackNumber); // Always 1 byte since we limit the range of trackNumber\n                bufferStream.writeU16BE(keyframe.timecode);\n                \n                // Flags byte\n                bufferStream.writeByte(\n                    1 << 7 // Keyframe\n                );\n                \n                return {\n                    \"id\": 0xA3, // SimpleBlock\n                    \"data\": [\n                         bufferStream.getAsDataArray(),\n                         keyframe.frame\n                    ]\n                };\n            }\n    \n            /**\n             * Create either a SimpleBlock or BlockGroup (if alpha is required) for the given keyframe.\n             *\n             * @param {Frame} keyframe\n             */\n            function createContainerForKeyframe(keyframe) {\n                if (keyframe.alpha) {\n                    return createBlockGroupForTransparentKeyframe(keyframe);\n                }\n                \n                return createSimpleBlockForKeyframe(keyframe);\n            }\n        \n            /**\n             * Create a Cluster EBML node.\n             *\n             * @param {Cluster} cluster\n             *\n             * Returns an EBML element.\n             */\n            function createCluster(cluster) {\n                return {\n                    \"id\": 0x1f43b675,\n                    \"data\": [\n                         {\n                            \"id\": 0xe7, // Timecode\n                            \"data\": Math.round(cluster.timecode)\n                         }\n                    ]\n                };\n            }\n            \n            function addCuePoint(trackIndex, clusterTime, clusterFileOffset) {\n                cues.push({\n                    \"id\": 0xBB, // Cue\n                    \"data\": [\n                         {\n                             \"id\": 0xB3, // CueTime\n                             \"data\": clusterTime\n                         },\n                         {\n                             \"id\": 0xB7, // CueTrackPositions\n                             \"data\": [\n                                  {\n                                      \"id\": 0xF7, // CueTrack\n                                      \"data\": trackIndex\n                                  },\n                                  {\n                                      \"id\": 0xF1, // CueClusterPosition\n                                      \"data\": fileOffsetToSegmentRelative(clusterFileOffset)\n                                  }\n                             ]\n                         }\n                    ]\n                });\n            }\n            \n            /**\n             * Write a Cues element to the blobStream using the global `cues` array of CuePoints (use addCuePoint()).\n             * The seek entry for the Cues in the SeekHead is updated.\n             */\n            function writeCues() {\n                let\n                    ebml = {\n                        \"id\": 0x1C53BB6B,\n                        \"data\": cues\n                    },\n                    \n                    cuesBuffer = new ArrayBufferDataStream(16 + cues.length * 32); // Pretty crude estimate of the buffer size we'll need\n                \n                writeEBML(cuesBuffer, blobBuffer.pos, ebml);\n                blobBuffer.write(cuesBuffer.getAsDataArray());\n                \n                // Now we know where the Cues element has ended up, we can update the SeekHead\n                seekPoints.Cues.positionEBML.data = fileOffsetToSegmentRelative(ebml.offset);\n            }\n            \n            /**\n             * Flush the frames in the current clusterFrameBuffer out to the stream as a Cluster.\n             */\n            function flushClusterFrameBuffer() {\n                if (clusterFrameBuffer.length === 0) {\n                    return;\n                }\n    \n                // First work out how large of a buffer we need to hold the cluster data\n                let\n                    rawImageSize = 0;\n                \n                for (let i = 0; i < clusterFrameBuffer.length; i++) {\n                    rawImageSize += clusterFrameBuffer[i].frame.length + (clusterFrameBuffer[i].alpha ? clusterFrameBuffer[i].alpha.length : 0);\n                }\n                \n                let\n                    buffer = new ArrayBufferDataStream(rawImageSize + clusterFrameBuffer.length * 64), // Estimate 64 bytes per block header\n    \n                    cluster = createCluster({\n                        timecode: Math.round(clusterStartTime),\n                    });\n                \n                for (let i = 0; i < clusterFrameBuffer.length; i++) {\n                    cluster.data.push(createContainerForKeyframe(clusterFrameBuffer[i]));\n                }\n                \n                writeEBML(buffer, blobBuffer.pos, cluster);\n                blobBuffer.write(buffer.getAsDataArray());\n                \n                addCuePoint(DEFAULT_TRACK_NUMBER, Math.round(clusterStartTime), cluster.offset);\n                \n                clusterFrameBuffer = [];\n                clusterStartTime += clusterDuration;\n                clusterDuration = 0;\n            }\n            \n            function validateOptions() {\n                // Derive frameDuration setting if not already supplied\n                if (!options.frameDuration) {\n                    if (options.frameRate) {\n                        options.frameDuration = 1000 / options.frameRate;\n                    } else {\n                        throw new Error(\"Missing required frameDuration or frameRate setting\");\n                    }\n                }\n                \n                // Avoid 1.0 (lossless) because it creates VP8L lossless frames that WebM doesn't support\n                options.quality = Math.max(Math.min(options.quality, 0.99999), 0);\n                \n                if (options.alphaQuality === undefined) {\n                    options.alphaQuality = options.quality;\n                } else {\n                    options.alphaQuality = Math.max(Math.min(options.alphaQuality, 0.99999), 0);\n                }\n            }\n    \n            /**\n             *\n             * @param {Frame} frame\n             */\n            function addFrameToCluster(frame) {\n                frame.trackNumber = DEFAULT_TRACK_NUMBER;\n                \n                // Frame timecodes are relative to the start of their cluster:\n                frame.timecode = Math.round(clusterDuration);\n    \n                clusterFrameBuffer.push(frame);\n                \n                clusterDuration += frame.duration;\n                \n                if (clusterDuration >= MAX_CLUSTER_DURATION_MSEC) {\n                    flushClusterFrameBuffer();\n                }\n            }\n            \n            /**\n             * Rewrites the SeekHead element that was initially written to the stream with the offsets of top level elements.\n             *\n             * Call once writing is complete (so the offset of all top level elements is known).\n             */\n            function rewriteSeekHead() {\n                let\n                    seekHeadBuffer = new ArrayBufferDataStream(seekHead.size),\n                    oldPos = blobBuffer.pos;\n                \n                // Write the rewritten SeekHead element's data payload to the stream (don't need to update the id or size)\n                writeEBML(seekHeadBuffer, seekHead.dataOffset, seekHead.data);\n                \n                // And write that through to the file\n                blobBuffer.seek(seekHead.dataOffset);\n                blobBuffer.write(seekHeadBuffer.getAsDataArray());\n    \n                blobBuffer.seek(oldPos);\n            }\n            \n            /**\n             * Rewrite the Duration field of the Segment with the newly-discovered video duration.\n             */\n            function rewriteDuration() {\n                let\n                    buffer = new ArrayBufferDataStream(8),\n                    oldPos = blobBuffer.pos;\n                \n                // Rewrite the data payload (don't need to update the id or size)\n                buffer.writeDoubleBE(clusterStartTime);\n                \n                // And write that through to the file\n                blobBuffer.seek(segmentDuration.dataOffset);\n                blobBuffer.write(buffer.getAsDataArray());\n        \n                blobBuffer.seek(oldPos);\n            }\n    \n            /**\n             * Rewrite the size field of the Segment.\n             */\n            function rewriteSegmentLength() {\n                let\n                    buffer = new ArrayBufferDataStream(10),\n                    oldPos = blobBuffer.pos;\n    \n                // We just need to rewrite the ID and Size fields of the root Segment:\n                buffer.writeUnsignedIntBE(ebmlSegment.id);\n                buffer.writeEBMLVarIntWidth(blobBuffer.pos - ebmlSegment.dataOffset, 5);\n                \n                // And write that on top of the original:\n                blobBuffer.seek(ebmlSegment.offset);\n                blobBuffer.write(buffer.getAsDataArray());\n        \n                blobBuffer.seek(oldPos);\n            }\n            \n            /**\n             * Add a frame to the video.\n             *\n             * @param {HTMLCanvasElement|String} frame - A Canvas element that contains the frame, or a WebP string\n             *                                           you obtained by calling toDataUrl() on an image yourself.\n             *\n             * @param {HTMLCanvasElement|String} [alpha] - For transparent video, instead of including the alpha channel\n             *                                             in your provided `frame`, you can instead provide it separately\n             *                                             here. The alpha channel of this alpha canvas will be ignored,\n             *                                             encode your alpha information into this canvas' grayscale\n             *                                             brightness instead.\n             *\n             *                                             This is useful because it allows you to paint the colours\n             *                                             you need into your `frame` even in regions which are fully\n             *                                             transparent (which Canvas doesn't normally let you influence).\n             *                                             This allows you to control the colour of the fringing seen\n             *                                             around objects on transparent backgrounds.\n             *\n             * @param {Number} [overrideFrameDuration] - Set a duration for this frame (in milliseconds) that differs\n             *                                           from the default\n             */\n            this.addFrame = function(frame, alpha, overrideFrameDuration) {\n                if (!writtenHeader) {\n                    videoWidth = frame.width || 0;\n                    videoHeight = frame.height || 0;\n    \n                    writeHeader();\n                }\n    \n                let\n                    keyframe = extractKeyframeFromWebP(renderAsWebP(frame, options.quality)),\n                    frameDuration, frameAlpha = null;\n                \n                if (overrideFrameDuration) {\n                    frameDuration = overrideFrameDuration;\n                } else if (typeof alpha == \"number\") {\n                    frameDuration = alpha;\n                } else {\n                    frameDuration = options.frameDuration;\n                }\n                \n                if (options.transparent) {\n                    if (alpha instanceof HTMLCanvasElement || typeof alpha === \"string\") {\n                        frameAlpha = alpha;\n                    } else if (keyframe.hasAlpha) {\n                        frameAlpha = convertAlphaToGrayscaleImage(frame);\n                    }\n                }\n                \n                addFrameToCluster({\n                    frame: keyframe.frame,\n                    duration: frameDuration,\n                    alpha: frameAlpha ? extractKeyframeFromWebP(renderAsWebP(frameAlpha, options.alphaQuality)).frame : null\n                });\n            };\n            \n            /**\n             * Finish writing the video and return a Promise to signal completion.\n             *\n             * If the destination device was memory (i.e. options.fileWriter was not supplied), the Promise is resolved with\n             * a Blob with the contents of the entire video.\n             */\n            this.complete = function() {\n            \tif (!writtenHeader) {\n\t\t            writeHeader();\n\t            }\n\t            \n                flushClusterFrameBuffer();\n                writeCues();\n                \n                /* \n                 * Now the file is at its final length and the position of all elements is known, seek back to the\n                 * header and update pointers:\n                 */\n                \n                rewriteSeekHead();\n                rewriteDuration();\n                rewriteSegmentLength();\n                \n                return blobBuffer.complete('video/webm');\n            };\n            \n            this.getWrittenSize = function() {\n                return blobBuffer.length;\n            };\n    \n            options = extend(optionDefaults, options || {});\n            validateOptions();\n        };\n    };\n    \n    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n\t    module.exports = WebMWriter;\n    } else {\n\t    window.WebMWriter = WebMWriter(window.ArrayBufferDataStream, window.BlobBuffer);\n    }\n})();\n"],"names":["renderAsWebP","canvas","quality","decodeBase64WebPDataURL","url","match","Error","window","atob","substring","test","toDataURL","extractKeyframeFromWebP","webP","cursor","indexOf","hasAlpha","length","string","chunkLength","fourCC","a","charCodeAt","b","c","d","frame","EBMLFloat32","value","EBMLFloat64","writeEBML","buffer","bufferFileOffset","ebml","Array","isArray","i","writeString","Uint8Array","writeBytes","id","offset","pos","writeUnsignedIntBE","data","sizePos","dataBegin","dataEnd","size","writeByte","dataOffset","seek","writeEBMLVarIntWidth","writeEBMLVarInt","measureUnsignedInt","writeDoubleBE","writeFloatBE","byteLength","WebMWriter","ArrayBufferDataStream","BlobBuffer","options","target","writtenHeader","videoWidth","videoHeight","alphaBuffer","alphaBufferContext","alphaBufferData","clusterFrameBuffer","clusterStartTime","clusterDuration","seekPoints","Cues","positionEBML","SegmentInfo","Tracks","ebmlSegment","segmentDuration","seekHead","cues","blobBuffer","fileWriter","fd","fileOffsetToSegmentRelative","fileOffset","writeHeader","createSeekHead","seekPositionEBMLTemplate","result","name","seekPoint","Object","create","push","segmentInfo","videoProperties","transparent","tracks","bufferStream","write","getAsDataArray","flushClusterFrameBuffer","keyframe","clusterTime","clusterFileOffset","rawImageSize","alpha","cluster","Math","round","createBlockGroupForTransparentKeyframe","trackNumber","writeU16BE","timecode","createSimpleBlockForKeyframe","addFrame","overrideFrameDuration","width","height","frameDuration","frameAlpha","HTMLCanvasElement","convertAlphaToGrayscaleImage","source","document","createElement","getContext","createImageData","sourceData","sourceContext","getImageData","destData","dstCursor","srcEnd","srcCursor","putImageData","duration","alphaQuality","complete","cuesBuffer","seekHeadBuffer","oldPos","getWrittenSize","undefined","frameRate","forEach","obj","prop","prototype","hasOwnProperty","call","validateOptions","max","min","module","exports"],"version":3,"file":"index.dbcadfc6.js.map"}